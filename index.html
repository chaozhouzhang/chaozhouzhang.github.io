<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Android技术堆栈">
<meta property="og:url" content="https:&#x2F;&#x2F;chaozhouzhang.github.io&#x2F;index.html">
<meta property="og:site_name" content="Android技术堆栈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chaozhouzhang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Android技术堆栈</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Android技术堆栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">视音频技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-19 12:28:18 / Modified: 20:42:07" itemprop="dateCreated datePublished" datetime="2021-09-19T12:28:18+08:00">2021-09-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、视频播放原理"><a href="#1、视频播放原理" class="headerlink" title="1、视频播放原理"></a>1、视频播放原理</h1><p><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/player.jpeg?raw=true" alt="视频播放原理"></p>
<h2 id="1-1、播放器"><a href="#1-1、播放器" class="headerlink" title="1.1、播放器"></a>1.1、播放器</h2><p>视音频技术包括流媒体协议技术、封装技术、视音频压缩编码技术。</p>
<table>
<thead>
<tr>
<th>播放器</th>
</tr>
</thead>
<tbody><tr>
<td>Media Player Classic - HC</td>
</tr>
<tr>
<td>MPlayer</td>
</tr>
<tr>
<td>FFPlay</td>
</tr>
<tr>
<td>XBMC</td>
</tr>
</tbody></table>
<h2 id="1-2、流媒体协议"><a href="#1-2、流媒体协议" class="headerlink" title="1.2、流媒体协议"></a>1.2、流媒体协议</h2><p>流媒体协议是服务器与客户端之间通信遵循的规定，视音频采用各种流媒体协议，在网络上传输视音频数据的同时，也会传输信令数据，包括对播放的控制或者对网络状态的描述等。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>传输层协议</th>
<th>客户端</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>RTSP+RTP</td>
<td>IETF</td>
<td>TCP+UDP</td>
<td>VLC,WMP</td>
<td>IPTV</td>
</tr>
<tr>
<td>RTMP</td>
<td>Adobe Inc.</td>
<td>TCP</td>
<td>Flash</td>
<td>互联网直播</td>
</tr>
<tr>
<td>RTMFP</td>
<td>Adobe Inc.</td>
<td>UDP</td>
<td>Flash</td>
<td>互联网直播</td>
</tr>
<tr>
<td>MMS</td>
<td>Microsoft Inc.</td>
<td>TCP/UDP</td>
<td>WMP</td>
<td>互联网直播+点播</td>
</tr>
<tr>
<td>HTTP</td>
<td>WWW+IETF</td>
<td>TCP</td>
<td>Flash</td>
<td>互联网点播</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>概览</th>
</tr>
</thead>
<tbody><tr>
<td>RTSP+RTP</td>
<td>采用UDP传输视音频，支持组播，效率较高，常用于IPTV领域。</td>
</tr>
<tr>
<td></td>
<td>但其缺点是网络不好的情况下可能会丢包，影响视频观看质量，因而围绕IPTV视频质量的研究较多。</td>
</tr>
<tr>
<td></td>
<td>因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。</td>
</tr>
<tr>
<td>RTMP，MMS，HTTP</td>
<td>互联网视频服务通常采用TCP作其流媒体的传输层协议，因而RTMP，MMS，HTTP这类协议广泛用于互联网视音频服务之中。</td>
</tr>
<tr>
<td></td>
<td>这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。</td>
</tr>
<tr>
<td>RTMFP</td>
<td>较新的流媒体协议，特点是支持P2P。</td>
</tr>
</tbody></table>
<h2 id="1-3、解协议"><a href="#1-3、解协议" class="headerlink" title="1.3、解协议"></a>1.3、解协议</h2><p>将流媒体协议的数据，解析为标准的相应的封装格式数据。<br>解协议的过程中会去除掉信令数据而只保留视音频数据。<br>例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<h2 id="1-4、封装格式"><a href="#1-4、封装格式" class="headerlink" title="1.4、封装格式"></a>1.4、封装格式</h2><p>将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。<br>有些封装格式支持的视音频编码标准十分广泛，算比较优秀的封装格式，比如MKV；<br>而有些封装格式支持的视音频编码标准很少，属于落后的封装格式，比如RMVB。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>流媒体</th>
<th>支持的视频编码</th>
<th>支持的音频编码</th>
<th>目前的使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>AVI</td>
<td>Microsoft Inc.</td>
<td>不支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>BT下载影视</td>
</tr>
<tr>
<td>MP4</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2, MPEG-4, H.264, H.263等</td>
<td>AAC, MPEG-1 Layers I, II, III, AC-3等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>TS</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-1, MPEG-2, MPEG-4, H.264</td>
<td>MPEG-1 Layers I, II, III, AAC</td>
<td>IPTV,数字电视</td>
</tr>
<tr>
<td>FLV</td>
<td>Adobe Inc.</td>
<td>支持</td>
<td>Sorenson, VP6, H.264</td>
<td>MP3, ADPCM, Linear PCM, AAC等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>MKV</td>
<td>CoreCodec Inc.</td>
<td>支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>RMVB</td>
<td>Real Networks Inc.</td>
<td>支持</td>
<td>RealVideo 8, 9, 10</td>
<td>AAC, Cook Codec, RealAudio Lossless</td>
<td>BT下载影视</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他封装格式</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
</tr>
<tr>
<td>WMV</td>
</tr>
</tbody></table>
<h2 id="1-5、解封装"><a href="#1-5、解封装" class="headerlink" title="1.5、解封装"></a>1.5、解封装</h2><p>将输入的封装格式数据，分离成音频流压缩编码数据和视频流压缩编码数据。<br>例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<h2 id="1-6、编码"><a href="#1-6、编码" class="headerlink" title="1.6、编码"></a>1.6、编码</h2><h3 id="1-6-1、视频压缩编码标准"><a href="#1-6-1、视频压缩编码标准" class="headerlink" title="1.6.1、视频压缩编码标准"></a>1.6.1、视频压缩编码标准</h3><p>视频编码的主要作用是将视频像素数据RGB，YUV等压缩成为视频码流，从而降低视频的数据量。<br>高效率的视频编码在同等的码率下，可以获得更高的视频质量。<br>当前使用最多的视频编码方案就是H.264。<br>在码率一定的情况下，编码标准的比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>HEVC(H.265)</td>
<td>MPEG/ITU-T</td>
<td>2013</td>
<td>研发中心</td>
</tr>
<tr>
<td>H.264</td>
<td>MPEG/ITU-T</td>
<td>2003</td>
<td>各个领域</td>
</tr>
<tr>
<td>MPEG4</td>
<td>MPEG</td>
<td>2001</td>
<td>不温不火</td>
</tr>
<tr>
<td>MPEG2</td>
<td>MPEG</td>
<td>1994</td>
<td>数字电视</td>
</tr>
<tr>
<td>VP9</td>
<td>Google</td>
<td>2013</td>
<td>研发中</td>
</tr>
<tr>
<td>VP8</td>
<td>Google</td>
<td>2008</td>
<td>不普及</td>
</tr>
<tr>
<td>VC-1</td>
<td>Microsoft Inc.</td>
<td>2006</td>
<td>微软平台</td>
</tr>
</tbody></table>
<p>视频压缩编码器</p>
<table>
<thead>
<tr>
<th>编码器</th>
<th>编码标准</th>
</tr>
</thead>
<tbody><tr>
<td>JM</td>
<td>H.264</td>
</tr>
<tr>
<td>x264</td>
<td>H.264</td>
</tr>
<tr>
<td>HM</td>
<td>H.265/HEVC</td>
</tr>
<tr>
<td>x265</td>
<td>H.265/HEVC</td>
</tr>
</tbody></table>
<h3 id="1-6-2、音频压缩编码标准"><a href="#1-6-2、音频压缩编码标准" class="headerlink" title="1.6.2、音频压缩编码标准"></a>1.6.2、音频压缩编码标准</h3><p>音频编码的主要作用是将音频采样数据PCM等压缩成为音频码流，从而降低音频的数据量。<br>高效率的音频编码在同等的码率下，可以获得更高的音质。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>AAC</td>
<td>MPEG</td>
<td>1997</td>
<td>各个领域</td>
</tr>
<tr>
<td>AC-3</td>
<td>Dolby Inc.</td>
<td>1992</td>
<td>电影</td>
</tr>
<tr>
<td>MP3</td>
<td>MPEG</td>
<td>1993</td>
<td>各个领域</td>
</tr>
<tr>
<td>WMA</td>
<td>Microsoft Inc.</td>
<td>1999</td>
<td>微软平台</td>
</tr>
</tbody></table>
<h2 id="1-7、解码"><a href="#1-7、解码" class="headerlink" title="1.7、解码"></a>1.7、解码</h2><p>将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。<br>通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P、RGB等等；<br>压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p>
<table>
<thead>
<tr>
<th>视频原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>YUV</td>
</tr>
<tr>
<td>RGB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>音频原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>PCM</td>
</tr>
</tbody></table>
<h2 id="1-8、视音频同步"><a href="#1-8、视音频同步" class="headerlink" title="1.8、视音频同步"></a>1.8、视音频同步</h2><p>根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<h2 id="1-9、网络视音频"><a href="#1-9、网络视音频" class="headerlink" title="1.9、网络视音频"></a>1.9、网络视音频</h2><h3 id="1-9-1、直播"><a href="#1-9-1、直播" class="headerlink" title="1.9.1、直播"></a>1.9.1、直播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。</span><br></pre></td></tr></table></figure>
<p>FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。</p>
<h3 id="1-9-2、点播"><a href="#1-9-2、点播" class="headerlink" title="1.9.2、点播"></a>1.9.2、点播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。</span><br></pre></td></tr></table></figure>
<p>采用HTTP作为点播协议有以下两点优势：<br>一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。<br>点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。</p>
<h2 id="1-10、视频参数对比"><a href="#1-10、视频参数对比" class="headerlink" title="1.10、视频参数对比"></a>1.10、视频参数对比</h2><table>
<thead>
<tr>
<th>名称</th>
<th>对比</th>
</tr>
</thead>
<tbody><tr>
<td>流媒体系统</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_streaming_media_software" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_streaming_media_software</a></td>
</tr>
<tr>
<td>封装格式</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_container_formats" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_container_formats</a></td>
</tr>
<tr>
<td>视频编码器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_codecs" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_codecs</a></td>
</tr>
<tr>
<td>音频编码器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_audio_coding_formats" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_audio_coding_formats</a></td>
</tr>
<tr>
<td>视频播放器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_player_software" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_player_software</a></td>
</tr>
</tbody></table>
<h1 id="2、视音频数据处理"><a href="#2、视音频数据处理" class="headerlink" title="2、视音频数据处理"></a>2、视音频数据处理</h1><h2 id="2-1、RGB、YUV视频像素数据处理"><a href="#2-1、RGB、YUV视频像素数据处理" class="headerlink" title="2.1、RGB、YUV视频像素数据处理"></a>2.1、RGB、YUV视频像素数据处理</h2><p>RGB/YUV视频像素数据在视频播放器的解码流程中的位置：<br><img src="" alt="视频像素数据"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java多线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-09 22:31:55" itemprop="dateCreated datePublished" datetime="2021-09-09T22:31:55+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-15 00:02:52" itemprop="dateModified" datetime="2021-09-15T00:02:52+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h3><p>1、定义Thread子类，重写线程执行体也就是run方法。<br>2、创建Thread子类的实例，也就是线程对象。<br>3、调用线程对象的start方法来启动该线程，也就是run方法中的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StackThread extends Thread &#123;</span><br><span class="line">    private int mNum = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();//有无均可，此时Thread中target肯定是空的。</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackThread stackThread = new StackThread();</span><br><span class="line">        stackThread.start();</span><br><span class="line">        StackThread stackThread1 = new StackThread();</span><br><span class="line">        stackThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>使用继承Thread类的方法创建线程类时，多个线程之间无法共享线程类的实例变量。</p>
<h3 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h3><p>1、定义Runnable接口的实现类，重写该接口的run方法。<br>2、创建Runnable实现类的实例，将实例作为Thread的target属性来创建线程对象。<br>3、调用线程对象的start方法来启动线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StackRunnable implements Runnable&#123;</span><br><span class="line">    private int mNum=0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        Thread thread = new Thread(stackRunnable);//此处的stackRunnable就是Thread中的target</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = new Thread(stackRunnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>使用Runnable接口的方式，创建多个使用共同target的线程时，多个线程共享Runnable实现类的变量。</p>
<h3 id="Thread与Runnable的关系"><a href="#Thread与Runnable的关系" class="headerlink" title="Thread与Runnable的关系"></a>Thread与Runnable的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">    	if (target != null) &#123;</span><br><span class="line">        	target.run();</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread类实现了Runnable接口，并且拥有Runnable类型的属性变量target。<br>所以若是以Thread子类的方式实现，则执行的是Thread子类的run方法；<br>若是以实现Runnable接口的方式实现，则执行的是Thread类中run方法，继而执行的是Runnable实现类中的run方法。<br>不存在既有Thread子类实现、又有Runnable接口实现的方式，Thread子类不能传入Runnable实现类实例作为构造参数来创建线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StackThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        StackThread thread = new StackThread(stackRunnable);//无法编译成功</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h3><p>Callable接口提供了一个call方法作为线程执行体。<br>特性：call方法有返回值，且可以抛出异常。<br>因为call方法有返回值，所以Callable接口是一个泛型接口，实现Callable接口的时候需要传入泛型类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future接口，是异步计算结果的容器接口。<br>提供了在等待异步计算完成时检查计算是否完成的状态，并在异步计算完成后获取计算结果而且只能通过 get 方法获取结果，如果异步计算没有完成则阻塞。<br>可以在异步计算完成前通过 cancel 方法取消，如果异步计算被取消则标记一个取消的状态。<br>如果希望异步计算可以被取消而且不提供可用的计算结果，则可以声明 Future&lt;?&gt; 形式类型，并返回 null 作为底层任务的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);//试图取消Future也就是FutureTask里关联的Callable任务。</span><br><span class="line">    boolean isCancelled();//如果在Callable任务正常完成前被取消，返回true。</span><br><span class="line">    boolean isDone();//任务已经结束，在任务完成、任务取消、任务异常的情况下都返回true。</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;//返回Callable任务里call方法的返回值，此方法会导致程序阻塞，必须等到子线程结束后才会得到返回值。</span><br><span class="line">    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;////如果在指定单位时间内没有返回值，将会抛出异常。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunnableFuture接口，继承了Future接口和Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask类，实现了RunnableFuture接口。"><a href="#FutureTask类，实现了RunnableFuture接口。" class="headerlink" title="FutureTask类，实现了RunnableFuture接口。"></a>FutureTask类，实现了RunnableFuture接口。</h4><p>Callable构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable和返回值构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Executors的callable方法将Runnable和结果值生成Callable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable适配器实现了Callable接口，并包含Runnable属性，实现的call方法中调用Runnable的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    private final Runnable task;</span><br><span class="line">    private final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final int NEW          = 0;//新建</span><br><span class="line">private static final int COMPLETING   = 1;//计算中</span><br><span class="line">private static final int NORMAL       = 2;//正常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;//异常</span><br><span class="line">private static final int CANCELLED    = 4;//已取消</span><br><span class="line">private static final int INTERRUPTING = 5;//中断中</span><br><span class="line">private static final int INTERRUPTED  = 6;//已中断</span><br></pre></td></tr></table></figure>
<p>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Callable&lt;V&gt; callable;//执行任务</span><br><span class="line">private Object outcome;//执行结果，或者异常</span><br><span class="line">private volatile Thread runner;//执行线程</span><br><span class="line">private volatile WaitNode waiters;//等待的线程栈</span><br></pre></td></tr></table></figure>
<p>FutureTask实现了Runnable接口，所以可以作为Thread的target，所以Thread执行的是FutureTask的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        runner = null;</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而FutureTask的run方法中执行的是Callable实例的call方法。<br>FutureTask的方法是阻塞方法，直到获取到到结果才返回值，结束阻塞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：<br>FutureTask与Callable：<br>1、创建Callable接口的实现类，并实现call方法作为线程执行体，并返回值，再创建Callable实现类的实例。<br>2、使用FutureTask类来包装Callable对象，FutureTask对象封装了Callable对象中call方法的返回值。<br>3、使用FutureTask对象作为Thread对象的target，创建并启动新线程。<br>4、调用FutureTask对象的get方法，来获取子线程执行结束后的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Integer callable() &#123;</span><br><span class="line">    Integer result=0;</span><br><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>FutureTask与Runnable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Integer result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>1、新建状态。<br>新建一个线程，Java虚拟机为其分配内存，并初始化其成员变量的值。<br>2、就绪状态。<br>当线程对象调用了start方法，线程处于就绪状态，Java虚拟机会为该线程创建方法调用栈和程序计数器，表示可以运行，什么时候运行取决于Java虚拟机里线程调度器的调度。<br>只能对处于新建状态的线程调用start方法，否则会抛出IllegalThreadStateException异常。<br>3、运行状态。<br>如果处于就绪状态的线程获得了CPU的时间，开始执行run方法的线程执行体，则该线程处于运行状态，多处理器的机器上将会有多个线程并行parallel执行。<br>4、阻塞状态。<br>除非线程的执行体够短，瞬间被执行结束，否则线程不会一直处于运行状态，线程在运行过程中会被中断，剥夺该线程所占用的资源，目的是使其他线程获得执行的机会。<br>抢占式调度。系统给每个线程一个时间片段执行，用完后执行其他线程，且会考虑线程的优先级。<br>协作式调度。线程主动调用了sleep或yeild方法后才会放弃所占用的资源。</p>
<p>线程将会进入阻塞状态：<br>线程调用sleep方法主动放弃所占用的处理器资源。<br>线程调用了一个阻塞式IO方法，在方法返回之前线程会被阻塞。<br>线程视图获取同步监视器，但该同步监视器正在被其他线程所持有。<br>线程在等待某个通知notify。<br>线程被调用了suspend方法被挂起。但suspend方法容易发生死锁，应该尽量避免使用。</p>
<p>当前正在执行的线程被阻塞后，其他就绪的线程将会获得执行的机会，之后在合适的时候被阻塞的线程将会重新进入就绪状态，等待系统调度器再次调度该线程。</p>
<p>解除阻塞，进入就绪状态：<br>调用sleep方法的线程进过了指定时间。<br>线程调用的阻塞式IO方法已经返回。<br>线程成功地获取了试图获取的同步监视器。<br>线程正在等待某个通知时，其他线程发送了一个通知。<br>处于挂起状态的线程被调用了resume恢复方法。</p>
<p>线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。<br>就绪状态线程获取处理器资源后进入运行状态，运行状态线程失去处理器资源后进入就绪状态，由系统线程调度决定。<br>调用yield方法可以让运行状态线程进入就绪状态。</p>
<p>5、死亡状态。<br>run方法或call方法执行完成，线程正常结束。<br>线程抛出一个未捕获的异常exception或错误error。<br>直接调用线程的stop方法结束线程，容易导致死锁，不建议使用。<br>线程的isAlive方法，判断线程是否存活，线程处于就绪、运行、阻塞状态返回true，线程处于新建、死亡状态返回false。</p>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><p>join线程：<br>在当前线程调用某线程的join方法，当前线程将被阻塞，直到某线程执行完成为止。</p>
<p>后台/守护/精灵/Daemon线程：<br>Java垃圾回收线程就是典型的后台线程。<br>如果所有的前台线程都死亡，那么后台线程会自动死亡。<br>调用线程的setDaemon(true)方法可以将线程设置为后台线程，但必须在start方法之前设置，否则会抛出IllegalThreadStateException异常。<br>线程的isDaemon方法判断方法是否是后台线程。</p>
<p>线程睡眠sleep：<br>调用线程的sleep方法，让正在执行的线程暂停一段时间，并进入阻塞状态，在其睡眠时间内，该线程不会获得执行的机会。</p>
<p>线程的yield方法只是让线程暂停一下，但不会让线程进入阻塞状态，而是让线程进入就绪状态，并让系统的线程调度重新调度，有可能又重新将该线程调度出来执行，具体哪个线程被调度到，需要看线程的优先级。</p>
<p>sleep方法声明了InterruptedException异常，yield方法没有，不建议使用yield方法控制并发线程的执行。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程默认优先级与创建它的父线程优先级相同。<br>线程通过setPriority(int newPriority)、getPriority设置和获取线程的优先级。<br>MAX_PRIORITY 10<br>MIN__PRIORITY 1<br>NORMAL_PRIORITY 5</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块。<br>线程的run方法不具备同步安全性，为了解决这个问题，Java的多线程引入了同步监视器，使用同步监视器的通用方法就是同步代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;</span><br><span class="line">	//同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obj就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。<br>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码执行完成后，该线程会释放对同步监视器的锁定。<br>同步监视器的目的：<br>阻止两个线程对同一个共享资源的并发访问，推荐使用可能被并发访问的共享资源充当同步监视器。</p>
<p>同步方法。<br>synchronized修饰的非静态实例方法，同步监视器是this，也就是调用该方法的对象。</p>
<p>线程安全的类：<br>该类的对象可以被多个线程安全地访问。<br>每个线程调用该对象的任意方法之后都将得到正确的结果。<br>每个线程调用该对象的任意方法之后，该对象的状态依然保持合理状态。</p>
<p>可变类的线程安全是以降低程序的运行效率作为代价的，所以只对会改变竞争资源的方法同步，且提供单线程和多线程两种版本，例如单线程使用StringBuilder保证性能，多线程使用StringBuffer保证多线程安全。</p>
<p>线程释放对同步监视器的锁定：<br>线程的同步方法、同步代码快执行结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到未处理的error和exception结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到break、return终止，释放同步监视器。<br>线程的同步代码块、同步方法执行的同时，程序执行了同步监视器对象的wait方法，当前线程暂停，释放同步监视器。而调用线程sleep方法和yield方法，其他线程调用该线程的suspend方法都不会释放同步监视器。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>通过显式定义同步锁Lock对象来实现同步，同步锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象。</p>
<p>读写锁：ReadWriteLock。<br>可重入锁：ReentrantLock，显式加锁、释放锁。<br>可重入性：线程可以对已被加锁的ReentrantLock锁对象再次加锁，ReentrantLock对象会维持一个计数器追踪lock方法的嵌套调用，线程每次调用lock加锁后，必须显式地调用unlock来释放锁，所以一段被锁保护的代码可以调用另一个被锁保护的代码。<br>可重入读写锁：ReentrantReadWriteLock。<br>StampedLock：是为了优化可重入读写锁性能的一个锁实现工具。<br>Lock显式地使用Lock对象作为同步锁，同步方法/块是系统隐式地使用当前对象作为同步监视器。<br>使用finally块，确保在必要时释放锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>线程互相等待对方释放同步监视器，就会发生死锁，所有线程处于阻塞状态，无法继续。<br>Thread类的suspend方法容易产生死锁，不建议使用。</p>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>Object类的wait、notify、notifyAll方法，由同步监视器对象来调用进行线程通信。</p>
<p>为什么wait，notify，notifyAll这些跟线程有关的方法是封装在Object中而不线程的Thread类呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为可以把任意的对象作为锁资源进行竞争，所以任意对象都可以调用wait()和notify()，而Object是所有类的父类，所以wait和notify属于Object。</span><br></pre></td></tr></table></figure>
<p>notify：唤醒在此对象监视器上等待的单个线程。<br>notifyAll：唤醒在此对象监视器上等待的所有线程。<br>wait：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法。<br>wait(long timeout)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者超过指定的时间量。<br>wait(long timeout, int nanos)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/28/OpenGL-ES-3-0-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/28/OpenGL-ES-3-0-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">OpenGL ES 3.0 编程指南读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-28 16:24:49 / Modified: 17:58:39" itemprop="dateCreated datePublished" datetime="2021-08-28T16:24:49+08:00">2021-08-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章、简介"><a href="#第一章、简介" class="headerlink" title="第一章、简介"></a>第一章、简介</h1><h2 id="0、OpenGL-ES"><a href="#0、OpenGL-ES" class="headerlink" title="0、OpenGL ES"></a>0、OpenGL ES</h2><p>OpenGL ES，Open Graphics Library for Embedded Systems，嵌入式系统的开放图形库。<br>OpenGL ES支持的平台有iOS、Android、BlackBerry、Linux、Windows，且是基于浏览器的3D图形Web标准WebGL的基础。<br>OpenGL ES规范有OpenGL ES 1.0、OpenGL ES 1.1、OpenGL ES2.0、OpenGL ES 3.0。<br>OpenGL ES 1.0和1.1采用固定功能管线，2.0采用可编程图形管线，3.0采用阴影贴图、体渲染、基于GPU的粒子动画、几何形状实例化、纹理压缩和伽马校正等技术。</p>
<h2 id="1-1、OpenGL-ES-3-0"><a href="#1-1、OpenGL-ES-3-0" class="headerlink" title="1.1、OpenGL ES 3.0"></a>1.1、OpenGL ES 3.0</h2><p>OpenGL ES 3.0实现了具有可编程着色功能的图形管线，由OpenGL ES3.0API规范和OpenGL ES着色语言3.0规范也就是OpenGL ES SL组成。</p>
<p>在OpenGL ES3.0图形管线的各个阶段中，顶点着色器和片段着色器是管线的可编程阶段。</p>
<p><img src="https://chaozhouzhang.github.io/images/OpenGL-ES-Graphics-Pipeline.png" alt="OpenGL ES3.0图形管线的各个阶段"></p>
<h3 id="1-1-1、顶点着色器"><a href="#1-1-1、顶点着色器" class="headerlink" title="1.1.1、顶点着色器"></a>1.1.1、顶点着色器</h3><p>顶点着色器实现了顶点操作的通用可编程方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/24/Kotlin%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/Kotlin%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Kotlin基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-24 00:23:24" itemprop="dateCreated datePublished" datetime="2021-08-24T00:23:24+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-28 16:53:10" itemprop="dateModified" datetime="2021-08-28T16:53:10+08:00">2021-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>var用于声明值从不更改的变量。<br>val用于声明值可以更改的变量。</p>
<h3 id="2、类型推断"><a href="#2、类型推断" class="headerlink" title="2、类型推断"></a>2、类型推断</h3><p>为变量赋予初始值后，Kotlin编译器可以根据所赋值的类型来推断其变量类型。</p>
<h3 id="3、null安全"><a href="#3、null安全" class="headerlink" title="3、null安全"></a>3、null安全</h3><p>在变量类型后面加上 ? 后缀，可将变量指定为 null。</p>
<h3 id="4、条件语句"><a href="#4、条件语句" class="headerlink" title="4、条件语句"></a>4、条件语句</h3><p>Kotlin 的条件语句彰显了智能类型转换功能。<br>if-else 表达式。<br>when 表达式。</p>
<h3 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h3><p>fun关键字声明函数。<br>函数返回单个表达式的结果时，可以通过直接返回函数中包含的 if-else 表达式的结果来跳过声明局部变量。</p>
<h3 id="6、匿名函数"><a href="#6、匿名函数" class="headerlink" title="6、匿名函数"></a>6、匿名函数</h3><p>匿名函数不需要名称，通过输入和输出更直接地进行标识。<br>可以保留对某个匿名函数的引用，以便日后使用此引用来调用该匿名函数。<br>与其他引用类型一样，也可以在应用中传递引用<br>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型)-&gt;返回值类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val stringLengthFunc: (String) -&gt; Int = &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;</span><br><span class="line">val stringLength: Int = stringLengthFunc(&quot;Android&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="7、高阶函数"><a href="#7、高阶函数" class="headerlink" title="7、高阶函数"></a>7、高阶函数</h3><p>将其他函数用作参数的函数称为高阶函数。此模式对组件之间的通信（其方式与在 Java 中使用回调接口相同）很有用。<br>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型)-&gt;返回值类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun stringMapper(str: String, mapper: (String) -&gt; Int): Int &#123;</span><br><span class="line">    return mapper(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果匿名函数是在某个函数上定义的最后一个参数，则可以在用于调用该函数的圆括号之外传递它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringMapper(&quot;Android&quot;) &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、类"><a href="#8、类" class="headerlink" title="8、类"></a>8、类</h3><p>class关键字定义类。</p>
<h3 id="9、属性"><a href="#9、属性" class="headerlink" title="9、属性"></a>9、属性</h3><p>类使用属性来表示状态。</p>
<h3 id="10、类函数和封装"><a href="#10、类函数和封装" class="headerlink" title="10、类函数和封装"></a>10、类函数和封装</h3><p>类使用函数对行为建模。<br>函数可以修改状态，从而只公开希望公开的数据。<br>这种访问控制机制属于一个面向对象的封装。</p>
<h3 id="11、互操作性"><a href="#11、互操作性" class="headerlink" title="11、互操作性"></a>11、互操作性</h3><p>由于 Kotlin 代码可编译为 JVM 字节码，因此 Kotlin 代码可直接调用 Java 代码，反之亦然。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Framework/" class="post-title-link" itemprop="url">Android内核剖析-Framework</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-19 00:26:58 / Modified: 00:34:08" itemprop="dateCreated datePublished" datetime="2021-08-19T00:26:58+08:00">2021-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Android内核剖析》内核篇读书笔记-Framework"><a href="#《Android内核剖析》内核篇读书笔记-Framework" class="headerlink" title="《Android内核剖析》内核篇读书笔记-Framework"></a>《Android内核剖析》内核篇读书笔记-Framework</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Binder/" class="post-title-link" itemprop="url">Android内核剖析-Framework</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-19 00:25:58 / Modified: 00:34:07" itemprop="dateCreated datePublished" datetime="2021-08-19T00:25:58+08:00">2021-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Android内核剖析》内核篇读书笔记-Binder"><a href="#《Android内核剖析》内核篇读书笔记-Binder" class="headerlink" title="《Android内核剖析》内核篇读书笔记-Binder"></a>《Android内核剖析》内核篇读书笔记-Binder</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/02/04/%E4%BD%BF%E7%94%A8%C2%A0APP_ABI%C2%A0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%89%B9%E5%AE%9A%20ABI%20%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/%E4%BD%BF%E7%94%A8%C2%A0APP_ABI%C2%A0%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%89%B9%E5%AE%9A%20ABI%20%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%9A/" class="post-title-link" itemprop="url">使用 APP_ABI 设置为特定 ABI 生成代码：</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-04 00:32:07" itemprop="dateCreated datePublished" datetime="2021-02-04T00:32:07+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用 APP_ABI 设置为特定 ABI 生成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APP_STL += gnustl_static</span><br><span class="line">APP_ABI := armeabi-v7a arm64-v8a</span><br><span class="line">APP_PLATFORM := android-16</span><br></pre></td></tr></table></figure>

<p>用于此应用的 C++ 标准库。<br>默认情况下使用 system STL。其他选项包括 c++_shared、c++_static 和 none</p>
<p>栈：在函数内部声明的所有变量都将占用栈内存。<br>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2020/12/07/SVN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/SVN/" class="post-title-link" itemprop="url">SVN</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-07 16:24:20 / Modified: 16:24:25" itemprop="dateCreated datePublished" datetime="2020-12-07T16:24:20+08:00">2020-12-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SVN使用</p>
<p>大版本发布后打个tag保存代码，没大的bug一般这部分代码就不再动了，万一以后线上出问题可以快速回溯</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2020/12/03/21%E5%A4%A9%E5%AD%A6%E9%80%9AC++%E7%AC%AC1%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/03/21%E5%A4%A9%E5%AD%A6%E9%80%9AC++%E7%AC%AC1%E5%A4%A9/" class="post-title-link" itemprop="url">21天学通C++第1天</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-03 23:18:04" itemprop="dateCreated datePublished" datetime="2020-12-03T23:18:04+08:00">2020-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-05 11:58:56" itemprop="dateModified" datetime="2020-12-05T11:58:56+08:00">2020-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><p>1、C++与C语言的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++是一种面向对象的语言，实现了继承、抽象、多态和封装等概念。</span><br><span class="line">C++支持类，而类包含成员数据以及操作成员数据的成员方法。</span><br><span class="line">很多C++编译器都支持C语言。</span><br><span class="line">学习C++等面向对象编程语言，并不需要先学习C语言等过程性语言，不要求具备C语言编程方面的知识和经验。</span><br></pre></td></tr></table></figure>
<p>2、C++的优点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++是一种中级编程语言，既可以高级编程方式编写应用程序，又可以低级编程方式编写与硬件紧密协作的库，控制应用程序的资源使用和性能。</span><br></pre></td></tr></table></figure>
<p>3、C++标准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++98</span><br><span class="line">C++03</span><br><span class="line">C++11</span><br><span class="line">C++14</span><br><span class="line">C++17</span><br><span class="line">C++20</span><br></pre></td></tr></table></figure>
<p>4、C++编译器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ICC</span><br><span class="line">GCC/g++ </span><br><span class="line">Clang</span><br><span class="line">MSVC</span><br><span class="line">VC++</span><br></pre></td></tr></table></figure>
<p>5、C++标准库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准函数库：由通用的、独立的、不属于任何类的函数组成，继承自 C 语言。</span><br><span class="line">面向对象类库：是类及其相关函数的集合。</span><br></pre></td></tr></table></figure>
<p>标准函数库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入/输出 I/O</span><br><span class="line">字符串和字符处理</span><br><span class="line">数学</span><br><span class="line">时间、日期和本地化</span><br><span class="line">动态分配</span><br><span class="line">其他</span><br><span class="line">宽字符函数</span><br></pre></td></tr></table></figure>
<p>面向对象类库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准的 C++ I/O 类</span><br><span class="line">String 类</span><br><span class="line">数值类</span><br><span class="line">STL 容器类</span><br><span class="line">STL 算法</span><br><span class="line">STL 函数对象</span><br><span class="line">STL 迭代器</span><br><span class="line">STL 分配器</span><br><span class="line">本地化库</span><br><span class="line">异常处理类</span><br><span class="line">杂项支持库</span><br></pre></td></tr></table></figure>
<p>C++ Standard Library headers</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://en.cppreference.com/w/cpp/header</span><br></pre></td></tr></table></figure>
<p>6、C++标准模板库STL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++标准模板库STL是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</span><br></pre></td></tr></table></figure>
<p>6、编译器对C++标准的支持<br>C++11</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.klayge.org/wiki/index.php/%E5%A4%9A%E7%A7%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9C%2B%2B11%E7%9A%84%E6%94%AF%E6%8C%81</span><br></pre></td></tr></table></figure>
<p>C++14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.klayge.org/wiki/index.php/%E5%A4%9A%E7%A7%8D%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9C%2B%2B14%E7%9A%84%E6%94%AF%E6%8C%81</span><br></pre></td></tr></table></figure>

<p>7、链接器</p>
<p>8、C/C++ 程序编译过程<br>源代码（source coprede）→预处理器（processor）→编译器（compiler）→汇编程序（assembler）→目标程序（object code）→链接器（Linker）→可执行程序（executables）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.sunistudio.com/cppfaq/</span><br></pre></td></tr></table></figure>

<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>C++程序被组织成类，而类由成员函数和成员变量组成。 </p>
<p>以#打头的预处理器编译指令以及以 int main( )打头的程序 主体。 </p>
<p>预处理器是一个在编译前运行的工具。预处理器编译指令是向预处理器发出的命令， 总是以字符#打头。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;filename&gt;让预处理器获取指定文件的内容，并将它们放在编译指令所处的位置。</span><br></pre></td></tr></table></figure>
<p>std<br>standard</p>
<p>cout是在名称空间std中定义的一个控制台流，使用流插入运算符&lt;&lt;将文本放入这个流中，std::endl是将回车插入这个流中，cout将会把内容显示到控制台中。<br>类似的，fstream是在名称空间std中定义个一个文件流，使用流插入运算符&lt;&lt;可将文本插入流中，fstream将会把内容存储到磁盘的文件中。</p>
<p>这个整数值被返回给操作系统，根据应用程序的性质，这可能很有用，因为大多数操作系 统都提供了查询功能，让您能够获悉正常终止的应用程序的返回值。在很多情况下，一个应用程序被 另一个应用程序启动，而父应用程序(启动者)想知道子应用程序(被启动者)是否成功地完成了其 任务。程序员可使用 main( )的返回值向父应用程序传递成功或错误状态。 </p>
<p>根据约定，程序员在程序运行成功时返回 0，并在出现错误时返回−1。然而，返回值为 整数，程序员可利用整个整数范围，指出众多不同的成功或失败状态。 </p>
<p>使用命名空间，严谨版本，没有包含整个名称空间，而只包含要使用的元素。 </p>
<p>务必添加注释，对程序中复杂算法和复杂部分 的工作原理进行解释。<br>务必以其他程序员能够理解的方式编写注释。<br>不要使用注释来解释显而易见的代码。<br>别忘了，不要因为可以添加注释，就编写晦涩 难懂的代码。<br>别忘了，修改代码时，可能需要相应地更新 注释。 </p>
<p>变量让程序员能够将数据临时存储一段时间，而常量让程序员能够定义不允许修改的东西。 </p>
<p>所有计算机、智能手机及其他可编程设备都包含微处理器和一定数量的临时存储空间，这种临时 存储器被称为随机存取存储器(RAM)。另外，很多设备还让您能够将数据永久性地存储到硬盘等存 储设备中。微处理器负责执行应用程序，在此过程中，它从 RAM 中获取要执行的应用程序二进制码 以及相关联的数据，这包括显示到屏幕上的数据以及用户输入的数据。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2020/11/30/ConstraintLayout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/30/ConstraintLayout/" class="post-title-link" itemprop="url">ConstraintLayout常用技巧</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-30 13:14:08 / Modified: 13:16:24" itemprop="dateCreated datePublished" datetime="2020-11-30T13:14:08+08:00">2020-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ConstraintLayout-常用技巧"><a href="#ConstraintLayout-常用技巧" class="headerlink" title="ConstraintLayout 常用技巧"></a>ConstraintLayout 常用技巧</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张潮州"
    src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">张潮州</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张潮州</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  

</body>
</html>
