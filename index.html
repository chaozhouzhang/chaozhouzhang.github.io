<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Android技术堆栈">
<meta property="og:url" content="https:&#x2F;&#x2F;chaozhouzhang.github.io&#x2F;index.html">
<meta property="og:site_name" content="Android技术堆栈">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chaozhouzhang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Android技术堆栈</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Android技术堆栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-PCM%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-PCM%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">视音频技术-PCM音频采样数据</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-20 17:04:12" itemprop="dateCreated datePublished" datetime="2021-09-20T17:04:12+08:00">2021-09-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-FFmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-FFmpeg%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">视音频技术-FFmpeg命令行基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-20 16:42:42" itemprop="dateCreated datePublished" datetime="2021-09-20T16:42:42+08:00">2021-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-21 16:32:19" itemprop="dateModified" datetime="2021-09-21T16:32:19+08:00">2021-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、FFmpeg命令行基础"><a href="#1、FFmpeg命令行基础" class="headerlink" title="1、FFmpeg命令行基础"></a>1、FFmpeg命令行基础</h1><p>FFmpeg官网：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ffmpeg.org/</span><br></pre></td></tr></table></figure>
<p>FFmpeg程序下载：包括Windows、MacOS、Linux等操作系统，包括FFmpeg、FFprobe、FFplay、FFserver等程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ffmpeg.org/download.html</span><br></pre></td></tr></table></figure>
<p>FFmpeg命令行文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ffmpeg.org/ffmpeg.html</span><br></pre></td></tr></table></figure>

<p>FFplay命令行文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ffmpeg.org/ffplay.html</span><br></pre></td></tr></table></figure>
<h2 id="2、配置FFmpeg环境变量"><a href="#2、配置FFmpeg环境变量" class="headerlink" title="2、配置FFmpeg环境变量"></a>2、配置FFmpeg环境变量</h2><p>MacOS上配置FFmpeg环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>按I键编辑文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:/Users/zhangchaozhou/Documents/Software/ffmpeg-4.4</span><br></pre></td></tr></table></figure>
<p>按ESC停止编辑，并按:wq键保存退出编辑。<br>更新配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>如果环境变量PATH被修改，需在命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/bin:/usr/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>执行FFmpeg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">TeochewZhang:video zhangchaozhou$ ffmpeg -hide_banner -help</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Getting help:</span><br><span class="line">    -h      -- print basic options</span><br><span class="line">    -h long -- print more options</span><br><span class="line">    -h full -- print all options (including all format and codec specific options, very long)</span><br><span class="line">    -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter/bsf/protocol</span><br><span class="line">    See man ffmpeg for detailed description of the options.</span><br><span class="line"></span><br><span class="line">Print help / information / capabilities:</span><br><span class="line">-L                  show license</span><br><span class="line">-h topic            show help</span><br><span class="line">-? topic            show help</span><br><span class="line">-help topic         show help</span><br><span class="line">--help topic        show help</span><br><span class="line">-version            show version</span><br><span class="line">-buildconf          show build configuration</span><br><span class="line">-formats            show available formats</span><br><span class="line">-muxers             show available muxers</span><br><span class="line">-demuxers           show available demuxers</span><br><span class="line">-devices            show available devices</span><br><span class="line">-codecs             show available codecs</span><br><span class="line">-decoders           show available decoders</span><br><span class="line">-encoders           show available encoders</span><br><span class="line">-bsfs               show available bit stream filters</span><br><span class="line">-protocols          show available protocols</span><br><span class="line">-filters            show available filters</span><br><span class="line">-pix_fmts           show available pixel formats</span><br><span class="line">-layouts            show standard channel layouts</span><br><span class="line">-sample_fmts        show available audio sample formats</span><br><span class="line">-colors             show available color names</span><br><span class="line">-sources device     list sources of the input device</span><br><span class="line">-sinks device       list sinks of the output device</span><br><span class="line">-hwaccels           show available HW acceleration methods</span><br><span class="line"></span><br><span class="line">Global options (affect whole program instead of just one file):</span><br><span class="line">-loglevel loglevel  set logging level</span><br><span class="line">-v loglevel         set logging level</span><br><span class="line">-report             generate a report</span><br><span class="line">-max_alloc bytes    set maximum size of a single allocated block</span><br><span class="line">-y                  overwrite output files</span><br><span class="line">-n                  never overwrite output files</span><br><span class="line">-ignore_unknown     Ignore unknown stream types</span><br><span class="line">-filter_threads     number of non-complex filter threads</span><br><span class="line">-filter_complex_threads  number of threads for -filter_complex</span><br><span class="line">-stats              print progress report during encoding</span><br><span class="line">-max_error_rate maximum error rate  ratio of decoding errors (0.0: no errors, 1.0: 100% errors) above which ffmpeg returns an error instead of success.</span><br><span class="line">-bits_per_raw_sample number  set the number of bits per raw sample</span><br><span class="line">-vol volume         change audio volume (256=normal)</span><br><span class="line"></span><br><span class="line">Per-file main options:</span><br><span class="line">-f fmt              force format</span><br><span class="line">-c codec            codec name</span><br><span class="line">-codec codec        codec name</span><br><span class="line">-pre preset         preset name</span><br><span class="line">-map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile</span><br><span class="line">-t duration         record or transcode &quot;duration&quot; seconds of audio/video</span><br><span class="line">-to time_stop       record or transcode stop time</span><br><span class="line">-fs limit_size      set the limit file size in bytes</span><br><span class="line">-ss time_off        set the start time offset</span><br><span class="line">-sseof time_off     set the start time offset relative to EOF</span><br><span class="line">-seek_timestamp     enable/disable seeking by timestamp with -ss</span><br><span class="line">-timestamp time     set the recording timestamp (&apos;now&apos; to set the current time)</span><br><span class="line">-metadata string=string  add metadata</span><br><span class="line">-program title=string:st=number...  add program with specified streams</span><br><span class="line">-target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)</span><br><span class="line">-apad               audio pad</span><br><span class="line">-frames number      set the number of frames to output</span><br><span class="line">-filter filter_graph  set stream filtergraph</span><br><span class="line">-filter_script filename  read stream filtergraph description from a file</span><br><span class="line">-reinit_filter      reinit filtergraph on input parameter changes</span><br><span class="line">-discard            discard</span><br><span class="line">-disposition        disposition</span><br><span class="line"></span><br><span class="line">Video options:</span><br><span class="line">-vframes number     set the number of video frames to output</span><br><span class="line">-r rate             set frame rate (Hz value, fraction or abbreviation)</span><br><span class="line">-fpsmax rate        set max frame rate (Hz value, fraction or abbreviation)</span><br><span class="line">-s size             set frame size (WxH or abbreviation)</span><br><span class="line">-aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)</span><br><span class="line">-bits_per_raw_sample number  set the number of bits per raw sample</span><br><span class="line">-vn                 disable video</span><br><span class="line">-vcodec codec       force video codec (&apos;copy&apos; to copy stream)</span><br><span class="line">-timecode hh:mm:ss[:;.]ff  set initial TimeCode value.</span><br><span class="line">-pass n             select the pass number (1 to 3)</span><br><span class="line">-vf filter_graph    set video filters</span><br><span class="line">-ab bitrate         audio bitrate (please use -b:a)</span><br><span class="line">-b bitrate          video bitrate (please use -b:v)</span><br><span class="line">-dn                 disable data</span><br><span class="line"></span><br><span class="line">Audio options:</span><br><span class="line">-aframes number     set the number of audio frames to output</span><br><span class="line">-aq quality         set audio quality (codec-specific)</span><br><span class="line">-ar rate            set audio sampling rate (in Hz)</span><br><span class="line">-ac channels        set number of audio channels</span><br><span class="line">-an                 disable audio</span><br><span class="line">-acodec codec       force audio codec (&apos;copy&apos; to copy stream)</span><br><span class="line">-vol volume         change audio volume (256=normal)</span><br><span class="line">-af filter_graph    set audio filters</span><br><span class="line"></span><br><span class="line">Subtitle options:</span><br><span class="line">-s size             set frame size (WxH or abbreviation)</span><br><span class="line">-sn                 disable subtitle</span><br><span class="line">-scodec codec       force subtitle codec (&apos;copy&apos; to copy stream)</span><br><span class="line">-stag fourcc/tag    force subtitle tag/fourcc</span><br><span class="line">-fix_sub_duration   fix subtitles duration</span><br><span class="line">-canvas_size size   set canvas size (WxH or abbreviation)</span><br><span class="line">-spre preset        set the subtitle options to the indicated preset</span><br></pre></td></tr></table></figure>

<h2 id="3、常用命令"><a href="#3、常用命令" class="headerlink" title="3、常用命令"></a>3、常用命令</h2><h3 id="3-1、获取文件信息"><a href="#3-1、获取文件信息" class="headerlink" title="3.1、获取文件信息"></a>3.1、获取文件信息</h3><p>使用-i参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4</span><br></pre></td></tr></table></figure>
<p>加上-hide_banner参数，可以只显示元信息，去除冗余信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4 -hide_banner</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TeochewZhang:video zhangchaozhou$ ffmpeg -i 那些年，我们一起追的女孩.mp4 -hide_banner</span><br><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;那些年，我们一起追的女孩.mp4&apos;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    encoder         : Lavf56.19.100</span><br><span class="line">  Duration: 00:00:30.32, start: 0.000000, bitrate: 397 kb/s</span><br><span class="line">  Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 480x208 [SAR 16:15 DAR 32:13], 261 kb/s, 25 fps, 25 tbr, 12800 tbn, 50 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br><span class="line">  Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br></pre></td></tr></table></figure>
<h3 id="3-2、转换编码格式-transcoding"><a href="#3-2、转换编码格式-transcoding" class="headerlink" title="3.2、转换编码格式/transcoding"></a>3.2、转换编码格式/transcoding</h3><p>将视频文件从一种编码转成另一种编码。比如转成 H.264 编码，一般使用编码器libx264，所以只需指定输出文件的视频编码器即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i [input.file] -c:v libx264 output.mp4</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">TeochewZhang:video zhangchaozhou$ ffmpeg -i Forrest_Gump_IMAX.mp4 -c:v libx264 output.mp4 -hide_banner</span><br><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;Forrest_Gump_IMAX.mp4&apos;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    encoder         : Lavf56.19.100</span><br><span class="line">  Duration: 00:00:31.21, start: 0.000000, bitrate: 878 kb/s</span><br><span class="line">  Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 640x352, 748 kb/s, 23.98 fps, 23.98 tbr, 24k tbn, 47.95 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br><span class="line">  Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br><span class="line">Stream mapping:</span><br><span class="line">  Stream #0:0 -&gt; #0:0 (h264 (native) -&gt; h264 (libx264))</span><br><span class="line">  Stream #0:1 -&gt; #0:1 (aac (native) -&gt; aac (native))</span><br><span class="line">Press [q] to stop, [?] for help</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] profile High, level 3.0, 4:2:0, 8-bit</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] 264 - core 161 r3048 b86ae3c - H.264/MPEG-4 AVC codec - Copyleft 2003-2021 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=11 lookahead_threads=1 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=23 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00</span><br><span class="line">Output #0, mp4, to &apos;output.mp4&apos;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2avc1mp41</span><br><span class="line">    encoder         : Lavf58.76.100</span><br><span class="line">  Stream #0:0(und): Video: h264 (avc1 / 0x31637661), yuv420p(progressive), 640x352, q=2-31, 23.98 fps, 24k tbn (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br><span class="line">      encoder         : Lavc58.134.100 libx264</span><br><span class="line">    Side data:</span><br><span class="line">      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A</span><br><span class="line">  Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 128 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br><span class="line">      vendor_id       : [0][0][0][0]</span><br><span class="line">      encoder         : Lavc58.134.100 aac</span><br><span class="line">frame=  744 fps=297 q=-1.0 Lsize=    3080kB time=00:00:31.18 bitrate= 809.1kbits/s speed=12.4x    </span><br><span class="line">video:2595kB audio:460kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.800888%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] frame I:20    Avg QP:17.34  size: 24048</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] frame P:245   Avg QP:22.46  size:  6089</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] frame B:479   Avg QP:24.79  size:  1428</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] consecutive B-frames:  7.0% 18.8%  8.1% 66.1%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] mb I  I16..4: 34.0% 22.0% 44.0%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] mb P  I16..4:  5.4%  8.7%  3.1%  P16..4: 30.5% 12.4%  7.2%  0.0%  0.0%    skip:32.7%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] mb B  I16..4:  0.7%  0.6%  0.4%  B16..8: 30.4%  4.7%  1.6%  direct: 2.1%  skip:59.5%  L0:45.2% L1:43.1% BI:11.7%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] 8x8 transform intra:40.6% inter:46.7%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] coded y,uvDC,uvAC intra: 45.5% 49.2% 16.2% inter: 12.0% 10.6% 0.5%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] i16 v,h,dc,p: 39% 35% 13% 13%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 15% 34% 20%  3%  5%  5%  6%  4%  6%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 15% 30% 13%  5%  7%  7%  8%  6%  8%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] i8c dc,h,v,p: 53% 31% 11%  5%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] Weighted P-Frames: Y:24.9% UV:20.4%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] ref P L0: 62.2% 20.9% 13.6%  3.0%  0.3%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] ref B L0: 89.2%  9.0%  1.7%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] ref B L1: 98.3%  1.7%</span><br><span class="line">[libx264 @ 0x7fcc4e803e00] kb/s:684.96</span><br><span class="line">[aac @ 0x7fcc4e805600] Qavg: 4577.948</span><br></pre></td></tr></table></figure>


<h3 id="3-3、转换容器格式-transmuxing"><a href="#3-3、转换容器格式-transmuxing" class="headerlink" title="3.3、转换容器格式/transmuxing"></a>3.3、转换容器格式/transmuxing</h3><p>将视频文件从一种容器转到另一种容器。<br>内部的编码格式不变，使用-c copy指定直接拷贝，不经过转码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -i input.mp4 -c copy output.webm</span><br></pre></td></tr></table></figure>
<h3 id="3-4、调整码率-transrating"><a href="#3-4、调整码率-transrating" class="headerlink" title="3.4、调整码率/transrating"></a>3.4、调整码率/transrating</h3><p>改变编码的比特率，一般用来将视频文件的体积变小。<br>指定码率最小为964K，最大为3856K，缓冲区大小为 2000K。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-minrate 964K -maxrate 3856K -bufsize 2000K \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>

<h3 id="3-5、改变分辨率-transsizing"><a href="#3-5、改变分辨率-transsizing" class="headerlink" title="3.5、改变分辨率/transsizing"></a>3.5、改变分辨率/transsizing</h3><p>从 1080p 转为 480p 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-vf scale=480:-1 \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>

<h3 id="3-6、提取音频-demuxing"><a href="#3-6、提取音频-demuxing" class="headerlink" title="3.6、提取音频/demuxing"></a>3.6、提取音频/demuxing</h3><p>从视频里面提取音频，-vn表示去掉视频，-c:a copy表示不改变音频编码，直接拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-vn -c:a copy \</span><br><span class="line">output.aac</span><br></pre></td></tr></table></figure>
<h3 id="3-7、添加音轨-muxing"><a href="#3-7、添加音轨-muxing" class="headerlink" title="3.7、添加音轨/muxing"></a>3.7、添加音轨/muxing</h3><p>将外部音频加入视频，比如添加背景音乐或旁白。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-i input.aac -i input.mp4 \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>

<h3 id="3-8、截图"><a href="#3-8、截图" class="headerlink" title="3.8、截图"></a>3.8、截图</h3><p>从指定时间开始，连续对1秒钟的视频进行截图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-y \</span><br><span class="line">-i input.mp4 \</span><br><span class="line">-ss 00:01:24 -t 00:00:01 \</span><br><span class="line">output_%3d.jpg</span><br></pre></td></tr></table></figure>
<p>指定只截取一，-vframes 1指定只截取一帧，-q:v 2表示输出的图片质量，一般是1到5之间（1 为质量最高）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg \</span><br><span class="line">-ss 01:23:45 \</span><br><span class="line">-i input \</span><br><span class="line">-vframes 1 -q:v 2 \</span><br><span class="line">output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="3-9、裁剪-cutting"><a href="#3-9、裁剪-cutting" class="headerlink" title="3.9、裁剪/cutting"></a>3.9、裁剪/cutting</h3><p>截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。<br>-c copy表示不改变音频和视频的编码格式，直接拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ffmpeg -ss [start] -i [input] -t [duration] -c copy [output]</span><br><span class="line">$ ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -ss 00:01:50 -i [input] -t 10.5 -c copy [output]</span><br><span class="line">$ ffmpeg -ss 2.5 -i [input] -to 10 -c copy [output]</span><br></pre></td></tr></table></figure>

<h3 id="3-10、为音频添加封面"><a href="#3-10、为音频添加封面" class="headerlink" title="3.10、为音频添加封面"></a>3.10、为音频添加封面</h3><p>有些视频网站只允许上传视频文件。如果要上传音频文件，必须为音频添加封面，将其转为视频，然后上传。<br>将音频文件，转为带封面的视频文件。</p>
<p>-loop 1参数表示图片无限循环，-shortest参数表示音频文件结束，输出视频就结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ffmpeg \</span><br><span class="line">-loop 1 \</span><br><span class="line">-i cover.jpg -i input.mp3 \</span><br><span class="line">-c:v libx264 -c:a aac -b:a 192k -shortest \</span><br><span class="line">output.mp4</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-YUV%E8%A7%86%E9%A2%91%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/20/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-YUV%E8%A7%86%E9%A2%91%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">视音频技术-YUV视频像素数据</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-20 11:07:17 / Modified: 16:05:20" itemprop="dateCreated datePublished" datetime="2021-09-20T11:07:17+08:00">2021-09-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、YUV视频像素数据"><a href="#1、YUV视频像素数据" class="headerlink" title="1、YUV视频像素数据"></a>1、YUV视频像素数据</h1><h2 id="1-1、YUV设计"><a href="#1-1、YUV设计" class="headerlink" title="1.1、YUV设计"></a>1.1、YUV设计</h2><p>YUV 是一种彩色编码系统，主要用在视频、图形处理流水线中。相对于 RGB 颜色空间，设计 YUV 的目的就是为了编码、传输的方便，减少带宽占用和信息出错。</p>
<p>Y’UV、YUV、YCbCr、YPbPr 几个概念其实是一回事儿。由于历史关系，Y’UV、YUV 主要是用在彩色电视中，用于模拟信号表示。YCbCr 是用在数字视频、图像的压缩和传输，如 MPEG、JPEG。通常所讲的 YUV 其实就是指 YCbCr，其中Y 表示亮度（luma），CbCr 表示色度（chroma）。</p>
<p>Y’UV 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是(UV)，那么在彩色电视显示的时候指显示亮度信息。Y’UV 不是 Absolute Color Space，只是一种 RGB 的信息编码，实际的显示还是通过 RGB 来显示。Y’，U，V 叫做不同的 component 。</p>
<p>人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感。在视频编码系统中为了降低带宽，可以保存更多的亮度信息(luma)，保存较少的色差信息(chroma)。这叫做 chrominance subsamping, 色度二次采样。原则：在数字图像中，(1) 每一个图形像素都要包含 luma（亮度）值；（2）几个图形像素共用一个 Cb + Cr 值，一般是 2、4、8 个像素。</p>
<h2 id="1-2、图形像素与亮度、色度的关系"><a href="#1-2、图形像素与亮度、色度的关系" class="headerlink" title="1.2、图形像素与亮度、色度的关系"></a>1.2、图形像素与亮度、色度的关系</h2><p>图形像素：<br>对于一个 w 宽、h 高的像素图，在水平方向，一行有 w 个像素；在垂直方向，一列有 h 个像素，整个图形有 w * h 个像素。</p>
<p>如果用 YCbCr 像素格式来表示像素图，需搞清楚亮度和图形像素的关系，色度和图形像素的关系。</p>
<table>
<thead>
<tr>
<th>YUV/YCbCr</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>明亮度</td>
</tr>
<tr>
<td>UV/CbCr</td>
<td>色度</td>
</tr>
</tbody></table>
<p> yuv 各种格式后面数字的含义：</p>
<p> <img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/yuv.jpg?raw=true" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">左侧一列，每一个小矩形是图形像素表示，黑框矩形是色度像素表示，小黑点是表示色度像素值(Cb+Cr)，表示图形像素和色度像素在水平和垂直方向的比例关系。</span><br><span class="line">4：4：0 水平方向是1/1，垂直方向是1/2，表示一个色度像素对应了两个图形像素。</span><br><span class="line">4：2：2 水平方向是1/2，垂直方向是1/1，表示一个色度像素对应了两个图形像素。</span><br><span class="line">4：2：0 水平方向是1/2，垂直方向是1/2，表示一个色度像素对应了四个图形像素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">右侧一列是二次采样模式记号表示，是 J：a：b 模式，实心黑色圆圈表示包含色度像素(Cb+Cr），空心圆圈表示不包含色度像素。对于 J:a:b 模式，主要是围绕参考块的概念定义的，这个参考块是一个 J x 2 的矩形，J 通常是 4。这样，此参考块就是宽度有 4 个像素、高度有 2 个像素的矩形。a 表示参考块的第一行包含的色度像素样本数，b 表示在参考块的第二行包含的色度像素样本数。</span><br><span class="line">4：4：0 参考块第一行包含四个色度样本，第二行没有包含色度样本。</span><br><span class="line">4：2：2 参考块第一行包含两个色度样本，第二行也包含两个色度样本，他们是交替出现。</span><br><span class="line">4：2：0 参考块第一行包含两个色度样本，第二行没有包含色度样本。</span><br></pre></td></tr></table></figure>

<p>yuv444，yuv422，yuv420 yuv 等像素格式的本质是：每个图形像素都会包含亮度值，但是某几个图形像素会共用一个色度值，这个比例关系就是通过 4 x 2 的矩形参考块来定的。</p>
<h2 id="1-3、YUV格式"><a href="#1-3、YUV格式" class="headerlink" title="1.3、YUV格式"></a>1.3、YUV格式</h2><table>
<thead>
<tr>
<th>YUV格式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>平面格式planar</td>
<td>用三个不同的数组来表示 YCbCr 的三个 Component，每一个 Component 都是通过不同的平面表示。</td>
</tr>
<tr>
<td>压缩格式packed</td>
<td>用一个数组表示 YCbCr，每一个 component 是交替出现的。</td>
</tr>
</tbody></table>
<h3 id="1-3-1、平面格式"><a href="#1-3-1、平面格式" class="headerlink" title="1.3.1、平面格式"></a>1.3.1、平面格式</h3><table>
<thead>
<tr>
<th>yuv420 planar/yuv420p/i420的位深度</th>
</tr>
</thead>
<tbody><tr>
<td>Y、U、V三个平面，每个平面8比特bit二进制数字表示</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果用 yuv420p 来表示分辨率为 1280 * 720 的图片，需要占用多少存储空间呢？</span><br><span class="line"></span><br><span class="line">每一个像素都需要一个 luma 值，即 y。那么总共需要 1280 * 720 = 921600 bytes。</span><br><span class="line">每四个像素需要一个 chroma u 值，那么总共需要 1280 * 720 / 4 = 230400 bytes。</span><br><span class="line">每四个像素需要一个 chroma v 值，那么总共需要 1280 * 720 / 4 = 230400 bytes。</span><br><span class="line">把 y、u、v 三个 plane 加起来就是：921600 + 230400 + 230400 = 1382400 bytes。</span><br></pre></td></tr></table></figure>


<p>通过ffmpeg将jpeg转成yuv，生成图形的分辨率是1280*72。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.jpeg -s 1280x720 -pix_fmt yuv420p test.yuv</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2、压缩格式"><a href="#1-3-2、压缩格式" class="headerlink" title="1.3.2、压缩格式"></a>1.3.2、压缩格式</h3><p>ffmpeg 中对 yuv420p 像素格式大小计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-RGB%E8%A7%86%E9%A2%91%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF-RGB%E8%A7%86%E9%A2%91%E5%83%8F%E7%B4%A0%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">视音频技术-RGB视频像素数据</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-19 12:29:20" itemprop="dateCreated datePublished" datetime="2021-09-19T12:29:20+08:00">2021-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-20 11:27:08" itemprop="dateModified" datetime="2021-09-20T11:27:08+08:00">2021-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、RGB视频像素数据"><a href="#1、RGB视频像素数据" class="headerlink" title="1、RGB视频像素数据"></a>1、RGB视频像素数据</h1><p>RGB色彩模式，是通过对红绿蓝三个颜色通道的变化，以及相互之间的叠加得到各种颜色。<br>每种颜色值范围为0-255，所以每个颜色值使用1个字节byte也就是8个比特bit表示。</p>
<h2 id="1-1、色深"><a href="#1-1、色深" class="headerlink" title="1.1、色深"></a>1.1、色深</h2><p>色深即色彩深度，色彩深度是计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多。</p>
<h2 id="1-2、RGB格式"><a href="#1-2、RGB格式" class="headerlink" title="1.2、RGB格式"></a>1.2、RGB格式</h2><h3 id="1-2-1、索引形式"><a href="#1-2-1、索引形式" class="headerlink" title="1.2.1、索引形式"></a>1.2.1、索引形式</h3><p>索引形式表示每个像素使用1、4、8个比特bit表示，存储的是对应像素在调色板的索引，而非像素的RGB分量值，调色板是通过编号映射到颜色的一张二维表。</p>
<table>
<thead>
<tr>
<th>索引形式</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>RGB1</td>
<td>黑白两种颜色</td>
</tr>
<tr>
<td>RGB4</td>
<td>16种颜色</td>
</tr>
<tr>
<td>RGB8</td>
<td>256种颜色</td>
</tr>
</tbody></table>
<h3 id="1-2-2、像素形式"><a href="#1-2-2、像素形式" class="headerlink" title="1.2.2、像素形式"></a>1.2.2、像素形式</h3><p>像素形式表示每个像素的RGB值使用N个比特bit表示。</p>
<table>
<thead>
<tr>
<th>像素形式</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>RGB565</td>
<td>R、G、B分别使用5、6、5个比特bit表示，共16个比特/位bit，2个字节byte，1个字Word</td>
</tr>
<tr>
<td>RGB55</td>
<td>RGB分别使用5个比特表示，剩余一位高字节不用，共16个比特</td>
</tr>
<tr>
<td>RGB24/RGB888</td>
<td>RGB分别使用8个比特表示，共24个比特</td>
</tr>
<tr>
<td>RGB32</td>
<td>RGB分别使用8个比特表示，剩余8位低字节不用，共32个比特</td>
</tr>
</tbody></table>
<p>假设计算机中存储某一个像素点的变量为color，数据类型为short。<br>RGB565：<br><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/RGB565.png?raw=true" alt="RGB565"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R = color &amp; 0xF800, (获取高字节的 5 个 bit)</span><br><span class="line">G = color &amp; 0x07E0, (获取中间 6 个 bit)</span><br><span class="line">B = color &amp; 0x001F, (获取低字节 5 个 bit)</span><br></pre></td></tr></table></figure>
<p>RGB55：<br><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/RGB55.png?raw=true" alt="RGB55"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R = color &amp; 0x7C00, (获取高字节的 5 个 bit)</span><br><span class="line">G = color &amp; 0x03E0, (获取中间 5 个 bit)</span><br><span class="line">B = color &amp; 0x001F, (获取低字节 5 个 bit)</span><br></pre></td></tr></table></figure>
<p>RGB24：<br><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/RGB24.png?raw=true" alt="RGB24"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R = color &amp; 0x000000FF, </span><br><span class="line">G = color &amp; 0x0000FF00,</span><br><span class="line">B = color &amp; 0x00FF0000,</span><br></pre></td></tr></table></figure>
<p>RGB32：<br><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/RGB32.png?raw=true" alt="RGB32"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R = color &amp; 0x0000FF00</span><br><span class="line">G = color &amp; 0x00FF0000,</span><br><span class="line">B = color &amp; 0xFF000000,</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3、RGB格式转换"><a href="#1-2-3、RGB格式转换" class="headerlink" title="1.2.3、RGB格式转换"></a>1.2.3、RGB格式转换</h3><p>RGB格式转换，由于精度不同，需要量化补偿和量化压缩。</p>
<h3 id="1-2-3-1、量化补偿："><a href="#1-2-3-1、量化补偿：" class="headerlink" title="1.2.3.1、量化补偿："></a>1.2.3.1、量化补偿：</h3><ol>
<li>将原数据填充至高位</li>
<li>对于低位，用原始数据的低位进行补偿</li>
<li>如果仍然有未填充的位，继续使用原始数据的低位进行循环补偿</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子： 16 bit RGB565 -&gt; 24 bit RGB888 的转换</span><br><span class="line">16 bit RGB656： R4 R3 R2 R1 R0 G5 G4 G3 G2 G1 G0 B4 B3 B2 B1 B0</span><br><span class="line">24 bit RGB888： R4 R3 R2 R1 R0 0 0 0 G5 G4 G3 G2 G1 G0 0 0 B4 B3 B2 B1 B0 0 0 0</span><br><span class="line">24 bit RGB888： R4 R3 R2 R1 R0 R2 R1 R0 G5 G4 G3 G2 G1 G0 G1 G0 B4 B3 B2 B1 B0 B2 B1 B0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void rgb565_to_rgb888(unsigned char *image, unsigned char *image888) </span><br><span class="line">&#123;</span><br><span class="line">    unsigned char R, G, B;</span><br><span class="line"></span><br><span class="line">    R = *(image + 1) &amp; 0xF8; // 补齐成：RRRRR000</span><br><span class="line">    G = (*(image + 1) &lt;&lt; 5) | (*image &amp; 0xe0 &gt;&gt; 3); // 补齐成：GGGGGG00</span><br><span class="line">    B = *image &lt;&lt; 3 ; // 补齐成: BBBBB000</span><br><span class="line"></span><br><span class="line">    // 补偿</span><br><span class="line">    *(image888) = B | ((B &amp; 0x38) &gt;&gt; 3); </span><br><span class="line">    *(image888 + 1) = G | ((G &amp; 0x0c) &gt;&gt; 2); </span><br><span class="line">    *(image888 + 2) = R | ((R &amp; 0x38) &gt;&gt; 3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-2、量化压缩："><a href="#1-2-3-2、量化压缩：" class="headerlink" title="1.2.3.2、量化压缩："></a>1.2.3.2、量化压缩：</h3><p>三个字取高位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子： 24 bit RGB888 -&gt; 16 bit RGB565 的转换</span><br><span class="line">24 bit RGB888：R7 R6 R5 R4 R3 R2 R1 R0 G7 G6 G5 G4 G3 G2 G1 G0 B7 B6 B5 B4 B3 B2 B1 B0</span><br><span class="line">16 bit RGB656： R7 R6 R5 R4 R3 G7 G6 G5 G4 G3 G2 B7 B6 B5 B4 B3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned short rgb_24_to_565(unsigned short r, unsigned short g, unsigned short b)</span><br><span class="line">&#123;</span><br><span class="line">    return ((r &lt;&lt; 8) &amp; 0xF800) | ((g &lt;&lt; 3) &amp; 0x07E0) | ((b &gt;&gt; 3) &amp; 0x001f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">视音频技术</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-19 12:28:18" itemprop="dateCreated datePublished" datetime="2021-09-19T12:28:18+08:00">2021-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-20 16:05:32" itemprop="dateModified" datetime="2021-09-20T16:05:32+08:00">2021-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、视频播放原理"><a href="#1、视频播放原理" class="headerlink" title="1、视频播放原理"></a>1、视频播放原理</h1><p><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/player.jpeg?raw=true" alt="视频播放原理"></p>
<h2 id="1-1、播放器"><a href="#1-1、播放器" class="headerlink" title="1.1、播放器"></a>1.1、播放器</h2><p>视音频技术包括流媒体协议技术、封装技术、视音频压缩编码技术。</p>
<table>
<thead>
<tr>
<th>播放器</th>
</tr>
</thead>
<tbody><tr>
<td>Media Player Classic - HC</td>
</tr>
<tr>
<td>MPlayer</td>
</tr>
<tr>
<td>FFPlay</td>
</tr>
<tr>
<td>XBMC</td>
</tr>
</tbody></table>
<h2 id="1-2、流媒体协议"><a href="#1-2、流媒体协议" class="headerlink" title="1.2、流媒体协议"></a>1.2、流媒体协议</h2><p>流媒体协议是服务器与客户端之间通信遵循的规定，视音频采用各种流媒体协议，在网络上传输视音频数据的同时，也会传输信令数据，包括对播放的控制或者对网络状态的描述等。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>传输层协议</th>
<th>客户端</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>RTSP+RTP</td>
<td>IETF</td>
<td>TCP+UDP</td>
<td>VLC,WMP</td>
<td>IPTV</td>
</tr>
<tr>
<td>RTMP</td>
<td>Adobe Inc.</td>
<td>TCP</td>
<td>Flash</td>
<td>互联网直播</td>
</tr>
<tr>
<td>RTMFP</td>
<td>Adobe Inc.</td>
<td>UDP</td>
<td>Flash</td>
<td>互联网直播</td>
</tr>
<tr>
<td>MMS</td>
<td>Microsoft Inc.</td>
<td>TCP/UDP</td>
<td>WMP</td>
<td>互联网直播+点播</td>
</tr>
<tr>
<td>HTTP</td>
<td>WWW+IETF</td>
<td>TCP</td>
<td>Flash</td>
<td>互联网点播</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>名称</th>
<th>概览</th>
</tr>
</thead>
<tbody><tr>
<td>RTSP+RTP</td>
<td>采用UDP传输视音频，支持组播，效率较高，常用于IPTV领域。</td>
</tr>
<tr>
<td></td>
<td>但其缺点是网络不好的情况下可能会丢包，影响视频观看质量，因而围绕IPTV视频质量的研究较多。</td>
</tr>
<tr>
<td></td>
<td>因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。</td>
</tr>
<tr>
<td>RTMP，MMS，HTTP</td>
<td>互联网视频服务通常采用TCP作其流媒体的传输层协议，因而RTMP，MMS，HTTP这类协议广泛用于互联网视音频服务之中。</td>
</tr>
<tr>
<td></td>
<td>这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。</td>
</tr>
<tr>
<td>RTMFP</td>
<td>较新的流媒体协议，特点是支持P2P。</td>
</tr>
</tbody></table>
<h2 id="1-3、解协议"><a href="#1-3、解协议" class="headerlink" title="1.3、解协议"></a>1.3、解协议</h2><p>将流媒体协议的数据，解析为标准的相应的封装格式数据。<br>解协议的过程中会去除掉信令数据而只保留视音频数据。<br>例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。</p>
<h2 id="1-4、封装格式"><a href="#1-4、封装格式" class="headerlink" title="1.4、封装格式"></a>1.4、封装格式</h2><p>将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。<br>有些封装格式支持的视音频编码标准十分广泛，算比较优秀的封装格式，比如MKV；<br>而有些封装格式支持的视音频编码标准很少，属于落后的封装格式，比如RMVB。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>流媒体</th>
<th>支持的视频编码</th>
<th>支持的音频编码</th>
<th>目前的使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>AVI</td>
<td>Microsoft Inc.</td>
<td>不支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>BT下载影视</td>
</tr>
<tr>
<td>MP4</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-2, MPEG-4, H.264, H.263等</td>
<td>AAC, MPEG-1 Layers I, II, III, AC-3等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>TS</td>
<td>MPEG</td>
<td>支持</td>
<td>MPEG-1, MPEG-2, MPEG-4, H.264</td>
<td>MPEG-1 Layers I, II, III, AAC</td>
<td>IPTV,数字电视</td>
</tr>
<tr>
<td>FLV</td>
<td>Adobe Inc.</td>
<td>支持</td>
<td>Sorenson, VP6, H.264</td>
<td>MP3, ADPCM, Linear PCM, AAC等</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>MKV</td>
<td>CoreCodec Inc.</td>
<td>支持</td>
<td>几乎所有格式</td>
<td>几乎所有格式</td>
<td>互联网视频网站</td>
</tr>
<tr>
<td>RMVB</td>
<td>Real Networks Inc.</td>
<td>支持</td>
<td>RealVideo 8, 9, 10</td>
<td>AAC, Cook Codec, RealAudio Lossless</td>
<td>BT下载影视</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>其他封装格式</th>
</tr>
</thead>
<tbody><tr>
<td>MOV</td>
</tr>
<tr>
<td>WMV</td>
</tr>
</tbody></table>
<h2 id="1-5、解封装"><a href="#1-5、解封装" class="headerlink" title="1.5、解封装"></a>1.5、解封装</h2><p>将输入的封装格式数据，分离成音频流压缩编码数据和视频流压缩编码数据。<br>例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。</p>
<h2 id="1-6、编码"><a href="#1-6、编码" class="headerlink" title="1.6、编码"></a>1.6、编码</h2><h3 id="1-6-1、视频压缩编码标准"><a href="#1-6-1、视频压缩编码标准" class="headerlink" title="1.6.1、视频压缩编码标准"></a>1.6.1、视频压缩编码标准</h3><p>视频编码的主要作用是将视频像素数据RGB，YUV等压缩成为【视频码流】，从而降低视频的数据量。<br>高效率的视频编码在同等的码率下，可以获得更高的视频质量。<br>当前使用最多的视频编码方案就是H.264。<br>在码率一定的情况下，编码标准的比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>HEVC(H.265)</td>
<td>MPEG/ITU-T</td>
<td>2013</td>
<td>研发中心</td>
</tr>
<tr>
<td>H.264</td>
<td>MPEG/ITU-T</td>
<td>2003</td>
<td>各个领域</td>
</tr>
<tr>
<td>MPEG4</td>
<td>MPEG</td>
<td>2001</td>
<td>不温不火</td>
</tr>
<tr>
<td>MPEG2</td>
<td>MPEG</td>
<td>1994</td>
<td>数字电视</td>
</tr>
<tr>
<td>VP9</td>
<td>Google</td>
<td>2013</td>
<td>研发中</td>
</tr>
<tr>
<td>VP8</td>
<td>Google</td>
<td>2008</td>
<td>不普及</td>
</tr>
<tr>
<td>VC-1</td>
<td>Microsoft Inc.</td>
<td>2006</td>
<td>微软平台</td>
</tr>
</tbody></table>
<p>视频压缩编码器</p>
<table>
<thead>
<tr>
<th>编码器</th>
<th>编码标准</th>
</tr>
</thead>
<tbody><tr>
<td>JM</td>
<td>H.264</td>
</tr>
<tr>
<td>x264</td>
<td>H.264</td>
</tr>
<tr>
<td>HM</td>
<td>H.265/HEVC</td>
</tr>
<tr>
<td>x265</td>
<td>H.265/HEVC</td>
</tr>
</tbody></table>
<h3 id="1-6-2、音频压缩编码标准"><a href="#1-6-2、音频压缩编码标准" class="headerlink" title="1.6.2、音频压缩编码标准"></a>1.6.2、音频压缩编码标准</h3><p>音频编码的主要作用是将音频采样数据PCM等压缩成为【音频码流】，从而降低音频的数据量。<br>高效率的音频编码在同等的码率下，可以获得更高的音质。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>推出机构</th>
<th>推出时间</th>
<th>目前使用领域</th>
</tr>
</thead>
<tbody><tr>
<td>AAC</td>
<td>MPEG</td>
<td>1997</td>
<td>各个领域</td>
</tr>
<tr>
<td>AC-3</td>
<td>Dolby Inc.</td>
<td>1992</td>
<td>电影</td>
</tr>
<tr>
<td>MP3</td>
<td>MPEG</td>
<td>1993</td>
<td>各个领域</td>
</tr>
<tr>
<td>WMA</td>
<td>Microsoft Inc.</td>
<td>1999</td>
<td>微软平台</td>
</tr>
</tbody></table>
<h2 id="1-7、解码"><a href="#1-7、解码" class="headerlink" title="1.7、解码"></a>1.7、解码</h2><p>将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。<br>通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P、RGB等等；<br>压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p>
<table>
<thead>
<tr>
<th>视频原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>YUV</td>
</tr>
<tr>
<td>RGB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>音频原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>PCM</td>
</tr>
</tbody></table>
<h2 id="1-8、视音频同步"><a href="#1-8、视音频同步" class="headerlink" title="1.8、视音频同步"></a>1.8、视音频同步</h2><p>根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<h2 id="1-9、网络视音频"><a href="#1-9、网络视音频" class="headerlink" title="1.9、网络视音频"></a>1.9、网络视音频</h2><h3 id="1-9-1、直播"><a href="#1-9-1、直播" class="headerlink" title="1.9.1、直播"></a>1.9.1、直播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。</span><br></pre></td></tr></table></figure>
<p>FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。</p>
<h3 id="1-9-2、点播"><a href="#1-9-2、点播" class="headerlink" title="1.9.2、点播"></a>1.9.2、点播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。</span><br></pre></td></tr></table></figure>
<p>采用HTTP作为点播协议有以下两点优势：<br>一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。<br>点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。</p>
<h2 id="1-10、视频参数对比"><a href="#1-10、视频参数对比" class="headerlink" title="1.10、视频参数对比"></a>1.10、视频参数对比</h2><table>
<thead>
<tr>
<th>名称</th>
<th>对比</th>
</tr>
</thead>
<tbody><tr>
<td>流媒体系统</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_streaming_media_software" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_streaming_media_software</a></td>
</tr>
<tr>
<td>封装格式</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_container_formats" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_container_formats</a></td>
</tr>
<tr>
<td>视频编码器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_codecs" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_codecs</a></td>
</tr>
<tr>
<td>音频编码器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_audio_coding_formats" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_audio_coding_formats</a></td>
</tr>
<tr>
<td>视频播放器</td>
<td><a href="https://en.wikipedia.org/wiki/Comparison_of_video_player_software" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_video_player_software</a></td>
</tr>
</tbody></table>
<h1 id="2、视音频数据处理"><a href="#2、视音频数据处理" class="headerlink" title="2、视音频数据处理"></a>2、视音频数据处理</h1><h2 id="2-1、RGB、YUV视频像素数据处理"><a href="#2-1、RGB、YUV视频像素数据处理" class="headerlink" title="2.1、RGB、YUV视频像素数据处理"></a>2.1、RGB、YUV视频像素数据处理</h2><p>RGB/YUV视频像素数据在视频播放器的解码流程中的位置：</p>
<p><img src="https://github.com/chaozhouzhang/chaozhouzhang.github.io/blob/master/images/rgb-yuv.png?raw=true" alt="视频像素数据"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java多线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-09 22:31:55" itemprop="dateCreated datePublished" datetime="2021-09-09T22:31:55+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-15 00:02:52" itemprop="dateModified" datetime="2021-09-15T00:02:52+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h3><p>1、定义Thread子类，重写线程执行体也就是run方法。<br>2、创建Thread子类的实例，也就是线程对象。<br>3、调用线程对象的start方法来启动该线程，也就是run方法中的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StackThread extends Thread &#123;</span><br><span class="line">    private int mNum = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();//有无均可，此时Thread中target肯定是空的。</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackThread stackThread = new StackThread();</span><br><span class="line">        stackThread.start();</span><br><span class="line">        StackThread stackThread1 = new StackThread();</span><br><span class="line">        stackThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>使用继承Thread类的方法创建线程类时，多个线程之间无法共享线程类的实例变量。</p>
<h3 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h3><p>1、定义Runnable接口的实现类，重写该接口的run方法。<br>2、创建Runnable实现类的实例，将实例作为Thread的target属性来创建线程对象。<br>3、调用线程对象的start方法来启动线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StackRunnable implements Runnable&#123;</span><br><span class="line">    private int mNum=0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        Thread thread = new Thread(stackRunnable);//此处的stackRunnable就是Thread中的target</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = new Thread(stackRunnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>使用Runnable接口的方式，创建多个使用共同target的线程时，多个线程共享Runnable实现类的变量。</p>
<h3 id="Thread与Runnable的关系"><a href="#Thread与Runnable的关系" class="headerlink" title="Thread与Runnable的关系"></a>Thread与Runnable的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">    	if (target != null) &#123;</span><br><span class="line">        	target.run();</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread类实现了Runnable接口，并且拥有Runnable类型的属性变量target。<br>所以若是以Thread子类的方式实现，则执行的是Thread子类的run方法；<br>若是以实现Runnable接口的方式实现，则执行的是Thread类中run方法，继而执行的是Runnable实现类中的run方法。<br>不存在既有Thread子类实现、又有Runnable接口实现的方式，Thread子类不能传入Runnable实现类实例作为构造参数来创建线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StackThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        StackThread thread = new StackThread(stackRunnable);//无法编译成功</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h3><p>Callable接口提供了一个call方法作为线程执行体。<br>特性：call方法有返回值，且可以抛出异常。<br>因为call方法有返回值，所以Callable接口是一个泛型接口，实现Callable接口的时候需要传入泛型类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future接口，是异步计算结果的容器接口。<br>提供了在等待异步计算完成时检查计算是否完成的状态，并在异步计算完成后获取计算结果而且只能通过 get 方法获取结果，如果异步计算没有完成则阻塞。<br>可以在异步计算完成前通过 cancel 方法取消，如果异步计算被取消则标记一个取消的状态。<br>如果希望异步计算可以被取消而且不提供可用的计算结果，则可以声明 Future&lt;?&gt; 形式类型，并返回 null 作为底层任务的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);//试图取消Future也就是FutureTask里关联的Callable任务。</span><br><span class="line">    boolean isCancelled();//如果在Callable任务正常完成前被取消，返回true。</span><br><span class="line">    boolean isDone();//任务已经结束，在任务完成、任务取消、任务异常的情况下都返回true。</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;//返回Callable任务里call方法的返回值，此方法会导致程序阻塞，必须等到子线程结束后才会得到返回值。</span><br><span class="line">    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;////如果在指定单位时间内没有返回值，将会抛出异常。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunnableFuture接口，继承了Future接口和Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask类，实现了RunnableFuture接口。"><a href="#FutureTask类，实现了RunnableFuture接口。" class="headerlink" title="FutureTask类，实现了RunnableFuture接口。"></a>FutureTask类，实现了RunnableFuture接口。</h4><p>Callable构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable和返回值构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Executors的callable方法将Runnable和结果值生成Callable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable适配器实现了Callable接口，并包含Runnable属性，实现的call方法中调用Runnable的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    private final Runnable task;</span><br><span class="line">    private final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final int NEW          = 0;//新建</span><br><span class="line">private static final int COMPLETING   = 1;//计算中</span><br><span class="line">private static final int NORMAL       = 2;//正常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;//异常</span><br><span class="line">private static final int CANCELLED    = 4;//已取消</span><br><span class="line">private static final int INTERRUPTING = 5;//中断中</span><br><span class="line">private static final int INTERRUPTED  = 6;//已中断</span><br></pre></td></tr></table></figure>
<p>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Callable&lt;V&gt; callable;//执行任务</span><br><span class="line">private Object outcome;//执行结果，或者异常</span><br><span class="line">private volatile Thread runner;//执行线程</span><br><span class="line">private volatile WaitNode waiters;//等待的线程栈</span><br></pre></td></tr></table></figure>
<p>FutureTask实现了Runnable接口，所以可以作为Thread的target，所以Thread执行的是FutureTask的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        runner = null;</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而FutureTask的run方法中执行的是Callable实例的call方法。<br>FutureTask的方法是阻塞方法，直到获取到到结果才返回值，结束阻塞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：<br>FutureTask与Callable：<br>1、创建Callable接口的实现类，并实现call方法作为线程执行体，并返回值，再创建Callable实现类的实例。<br>2、使用FutureTask类来包装Callable对象，FutureTask对象封装了Callable对象中call方法的返回值。<br>3、使用FutureTask对象作为Thread对象的target，创建并启动新线程。<br>4、调用FutureTask对象的get方法，来获取子线程执行结束后的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Integer callable() &#123;</span><br><span class="line">    Integer result=0;</span><br><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>FutureTask与Runnable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Integer result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>1、新建状态。<br>新建一个线程，Java虚拟机为其分配内存，并初始化其成员变量的值。<br>2、就绪状态。<br>当线程对象调用了start方法，线程处于就绪状态，Java虚拟机会为该线程创建方法调用栈和程序计数器，表示可以运行，什么时候运行取决于Java虚拟机里线程调度器的调度。<br>只能对处于新建状态的线程调用start方法，否则会抛出IllegalThreadStateException异常。<br>3、运行状态。<br>如果处于就绪状态的线程获得了CPU的时间，开始执行run方法的线程执行体，则该线程处于运行状态，多处理器的机器上将会有多个线程并行parallel执行。<br>4、阻塞状态。<br>除非线程的执行体够短，瞬间被执行结束，否则线程不会一直处于运行状态，线程在运行过程中会被中断，剥夺该线程所占用的资源，目的是使其他线程获得执行的机会。<br>抢占式调度。系统给每个线程一个时间片段执行，用完后执行其他线程，且会考虑线程的优先级。<br>协作式调度。线程主动调用了sleep或yeild方法后才会放弃所占用的资源。</p>
<p>线程将会进入阻塞状态：<br>线程调用sleep方法主动放弃所占用的处理器资源。<br>线程调用了一个阻塞式IO方法，在方法返回之前线程会被阻塞。<br>线程视图获取同步监视器，但该同步监视器正在被其他线程所持有。<br>线程在等待某个通知notify。<br>线程被调用了suspend方法被挂起。但suspend方法容易发生死锁，应该尽量避免使用。</p>
<p>当前正在执行的线程被阻塞后，其他就绪的线程将会获得执行的机会，之后在合适的时候被阻塞的线程将会重新进入就绪状态，等待系统调度器再次调度该线程。</p>
<p>解除阻塞，进入就绪状态：<br>调用sleep方法的线程进过了指定时间。<br>线程调用的阻塞式IO方法已经返回。<br>线程成功地获取了试图获取的同步监视器。<br>线程正在等待某个通知时，其他线程发送了一个通知。<br>处于挂起状态的线程被调用了resume恢复方法。</p>
<p>线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。<br>就绪状态线程获取处理器资源后进入运行状态，运行状态线程失去处理器资源后进入就绪状态，由系统线程调度决定。<br>调用yield方法可以让运行状态线程进入就绪状态。</p>
<p>5、死亡状态。<br>run方法或call方法执行完成，线程正常结束。<br>线程抛出一个未捕获的异常exception或错误error。<br>直接调用线程的stop方法结束线程，容易导致死锁，不建议使用。<br>线程的isAlive方法，判断线程是否存活，线程处于就绪、运行、阻塞状态返回true，线程处于新建、死亡状态返回false。</p>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><p>join线程：<br>在当前线程调用某线程的join方法，当前线程将被阻塞，直到某线程执行完成为止。</p>
<p>后台/守护/精灵/Daemon线程：<br>Java垃圾回收线程就是典型的后台线程。<br>如果所有的前台线程都死亡，那么后台线程会自动死亡。<br>调用线程的setDaemon(true)方法可以将线程设置为后台线程，但必须在start方法之前设置，否则会抛出IllegalThreadStateException异常。<br>线程的isDaemon方法判断方法是否是后台线程。</p>
<p>线程睡眠sleep：<br>调用线程的sleep方法，让正在执行的线程暂停一段时间，并进入阻塞状态，在其睡眠时间内，该线程不会获得执行的机会。</p>
<p>线程的yield方法只是让线程暂停一下，但不会让线程进入阻塞状态，而是让线程进入就绪状态，并让系统的线程调度重新调度，有可能又重新将该线程调度出来执行，具体哪个线程被调度到，需要看线程的优先级。</p>
<p>sleep方法声明了InterruptedException异常，yield方法没有，不建议使用yield方法控制并发线程的执行。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程默认优先级与创建它的父线程优先级相同。<br>线程通过setPriority(int newPriority)、getPriority设置和获取线程的优先级。<br>MAX_PRIORITY 10<br>MIN__PRIORITY 1<br>NORMAL_PRIORITY 5</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块。<br>线程的run方法不具备同步安全性，为了解决这个问题，Java的多线程引入了同步监视器，使用同步监视器的通用方法就是同步代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;</span><br><span class="line">	//同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obj就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。<br>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码执行完成后，该线程会释放对同步监视器的锁定。<br>同步监视器的目的：<br>阻止两个线程对同一个共享资源的并发访问，推荐使用可能被并发访问的共享资源充当同步监视器。</p>
<p>同步方法。<br>synchronized修饰的非静态实例方法，同步监视器是this，也就是调用该方法的对象。</p>
<p>线程安全的类：<br>该类的对象可以被多个线程安全地访问。<br>每个线程调用该对象的任意方法之后都将得到正确的结果。<br>每个线程调用该对象的任意方法之后，该对象的状态依然保持合理状态。</p>
<p>可变类的线程安全是以降低程序的运行效率作为代价的，所以只对会改变竞争资源的方法同步，且提供单线程和多线程两种版本，例如单线程使用StringBuilder保证性能，多线程使用StringBuffer保证多线程安全。</p>
<p>线程释放对同步监视器的锁定：<br>线程的同步方法、同步代码快执行结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到未处理的error和exception结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到break、return终止，释放同步监视器。<br>线程的同步代码块、同步方法执行的同时，程序执行了同步监视器对象的wait方法，当前线程暂停，释放同步监视器。而调用线程sleep方法和yield方法，其他线程调用该线程的suspend方法都不会释放同步监视器。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>通过显式定义同步锁Lock对象来实现同步，同步锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象。</p>
<p>读写锁：ReadWriteLock。<br>可重入锁：ReentrantLock，显式加锁、释放锁。<br>可重入性：线程可以对已被加锁的ReentrantLock锁对象再次加锁，ReentrantLock对象会维持一个计数器追踪lock方法的嵌套调用，线程每次调用lock加锁后，必须显式地调用unlock来释放锁，所以一段被锁保护的代码可以调用另一个被锁保护的代码。<br>可重入读写锁：ReentrantReadWriteLock。<br>StampedLock：是为了优化可重入读写锁性能的一个锁实现工具。<br>Lock显式地使用Lock对象作为同步锁，同步方法/块是系统隐式地使用当前对象作为同步监视器。<br>使用finally块，确保在必要时释放锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>线程互相等待对方释放同步监视器，就会发生死锁，所有线程处于阻塞状态，无法继续。<br>Thread类的suspend方法容易产生死锁，不建议使用。</p>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>Object类的wait、notify、notifyAll方法，由同步监视器对象来调用进行线程通信。</p>
<p>为什么wait，notify，notifyAll这些跟线程有关的方法是封装在Object中而不线程的Thread类呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为可以把任意的对象作为锁资源进行竞争，所以任意对象都可以调用wait()和notify()，而Object是所有类的父类，所以wait和notify属于Object。</span><br></pre></td></tr></table></figure>
<p>notify：唤醒在此对象监视器上等待的单个线程。<br>notifyAll：唤醒在此对象监视器上等待的所有线程。<br>wait：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法。<br>wait(long timeout)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者超过指定的时间量。<br>wait(long timeout, int nanos)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/28/OpenGL-ES-3-0-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/28/OpenGL-ES-3-0-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">OpenGL ES 3.0 编程指南读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-28 16:24:49 / Modified: 17:58:39" itemprop="dateCreated datePublished" datetime="2021-08-28T16:24:49+08:00">2021-08-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章、简介"><a href="#第一章、简介" class="headerlink" title="第一章、简介"></a>第一章、简介</h1><h2 id="0、OpenGL-ES"><a href="#0、OpenGL-ES" class="headerlink" title="0、OpenGL ES"></a>0、OpenGL ES</h2><p>OpenGL ES，Open Graphics Library for Embedded Systems，嵌入式系统的开放图形库。<br>OpenGL ES支持的平台有iOS、Android、BlackBerry、Linux、Windows，且是基于浏览器的3D图形Web标准WebGL的基础。<br>OpenGL ES规范有OpenGL ES 1.0、OpenGL ES 1.1、OpenGL ES2.0、OpenGL ES 3.0。<br>OpenGL ES 1.0和1.1采用固定功能管线，2.0采用可编程图形管线，3.0采用阴影贴图、体渲染、基于GPU的粒子动画、几何形状实例化、纹理压缩和伽马校正等技术。</p>
<h2 id="1-1、OpenGL-ES-3-0"><a href="#1-1、OpenGL-ES-3-0" class="headerlink" title="1.1、OpenGL ES 3.0"></a>1.1、OpenGL ES 3.0</h2><p>OpenGL ES 3.0实现了具有可编程着色功能的图形管线，由OpenGL ES3.0API规范和OpenGL ES着色语言3.0规范也就是OpenGL ES SL组成。</p>
<p>在OpenGL ES3.0图形管线的各个阶段中，顶点着色器和片段着色器是管线的可编程阶段。</p>
<p><img src="https://chaozhouzhang.github.io/images/OpenGL-ES-Graphics-Pipeline.png" alt="OpenGL ES3.0图形管线的各个阶段"></p>
<h3 id="1-1-1、顶点着色器"><a href="#1-1-1、顶点着色器" class="headerlink" title="1.1.1、顶点着色器"></a>1.1.1、顶点着色器</h3><p>顶点着色器实现了顶点操作的通用可编程方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/24/Kotlin%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/24/Kotlin%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Kotlin基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-24 00:23:24" itemprop="dateCreated datePublished" datetime="2021-08-24T00:23:24+08:00">2021-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-28 16:53:10" itemprop="dateModified" datetime="2021-08-28T16:53:10+08:00">2021-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>var用于声明值从不更改的变量。<br>val用于声明值可以更改的变量。</p>
<h3 id="2、类型推断"><a href="#2、类型推断" class="headerlink" title="2、类型推断"></a>2、类型推断</h3><p>为变量赋予初始值后，Kotlin编译器可以根据所赋值的类型来推断其变量类型。</p>
<h3 id="3、null安全"><a href="#3、null安全" class="headerlink" title="3、null安全"></a>3、null安全</h3><p>在变量类型后面加上 ? 后缀，可将变量指定为 null。</p>
<h3 id="4、条件语句"><a href="#4、条件语句" class="headerlink" title="4、条件语句"></a>4、条件语句</h3><p>Kotlin 的条件语句彰显了智能类型转换功能。<br>if-else 表达式。<br>when 表达式。</p>
<h3 id="5、函数"><a href="#5、函数" class="headerlink" title="5、函数"></a>5、函数</h3><p>fun关键字声明函数。<br>函数返回单个表达式的结果时，可以通过直接返回函数中包含的 if-else 表达式的结果来跳过声明局部变量。</p>
<h3 id="6、匿名函数"><a href="#6、匿名函数" class="headerlink" title="6、匿名函数"></a>6、匿名函数</h3><p>匿名函数不需要名称，通过输入和输出更直接地进行标识。<br>可以保留对某个匿名函数的引用，以便日后使用此引用来调用该匿名函数。<br>与其他引用类型一样，也可以在应用中传递引用<br>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型)-&gt;返回值类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val stringLengthFunc: (String) -&gt; Int = &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;</span><br><span class="line">val stringLength: Int = stringLengthFunc(&quot;Android&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="7、高阶函数"><a href="#7、高阶函数" class="headerlink" title="7、高阶函数"></a>7、高阶函数</h3><p>将其他函数用作参数的函数称为高阶函数。此模式对组件之间的通信（其方式与在 Java 中使用回调接口相同）很有用。<br>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型)-&gt;返回值类型</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun stringMapper(str: String, mapper: (String) -&gt; Int): Int &#123;</span><br><span class="line">    return mapper(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果匿名函数是在某个函数上定义的最后一个参数，则可以在用于调用该函数的圆括号之外传递它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringMapper(&quot;Android&quot;) &#123; input -&gt;</span><br><span class="line">    input.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、类"><a href="#8、类" class="headerlink" title="8、类"></a>8、类</h3><p>class关键字定义类。</p>
<h3 id="9、属性"><a href="#9、属性" class="headerlink" title="9、属性"></a>9、属性</h3><p>类使用属性来表示状态。</p>
<h3 id="10、类函数和封装"><a href="#10、类函数和封装" class="headerlink" title="10、类函数和封装"></a>10、类函数和封装</h3><p>类使用函数对行为建模。<br>函数可以修改状态，从而只公开希望公开的数据。<br>这种访问控制机制属于一个面向对象的封装。</p>
<h3 id="11、互操作性"><a href="#11、互操作性" class="headerlink" title="11、互操作性"></a>11、互操作性</h3><p>由于 Kotlin 代码可编译为 JVM 字节码，因此 Kotlin 代码可直接调用 Java 代码，反之亦然。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Framework/" class="post-title-link" itemprop="url">Android内核剖析-Framework</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-19 00:26:58 / Modified: 00:34:08" itemprop="dateCreated datePublished" datetime="2021-08-19T00:26:58+08:00">2021-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Android内核剖析》内核篇读书笔记-Framework"><a href="#《Android内核剖析》内核篇读书笔记-Framework" class="headerlink" title="《Android内核剖析》内核篇读书笔记-Framework"></a>《Android内核剖析》内核篇读书笔记-Framework</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/19/Android%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90-Binder/" class="post-title-link" itemprop="url">Android内核剖析-Framework</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-19 00:25:58 / Modified: 00:34:07" itemprop="dateCreated datePublished" datetime="2021-08-19T00:25:58+08:00">2021-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Android内核剖析》内核篇读书笔记-Binder"><a href="#《Android内核剖析》内核篇读书笔记-Binder" class="headerlink" title="《Android内核剖析》内核篇读书笔记-Binder"></a>《Android内核剖析》内核篇读书笔记-Binder</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张潮州"
    src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">张潮州</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张潮州</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  

</body>
</html>
