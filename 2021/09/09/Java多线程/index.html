<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="进程线程继承Thread类创建线程类1、定义Thread子类，重写线程执行体也就是run方法。2、创建Thread子类的实例，也就是线程对象。3、调用线程对象的start方法来启动该线程，也就是run方法中的代码。 1234567891011121314151617public class StackThread extends Thread &amp;#123;    private int mNum">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程">
<meta property="og:url" content="https:&#x2F;&#x2F;chaozhouzhang.github.io&#x2F;2021&#x2F;09&#x2F;09&#x2F;Java%E5%A4%9A%E7%BA%BF%E7%A8%8B&#x2F;index.html">
<meta property="og:site_name" content="Android技术堆栈">
<meta property="og:description" content="进程线程继承Thread类创建线程类1、定义Thread子类，重写线程执行体也就是run方法。2、创建Thread子类的实例，也就是线程对象。3、调用线程对象的start方法来启动该线程，也就是run方法中的代码。 1234567891011121314151617public class StackThread extends Thread &amp;#123;    private int mNum">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-09-14T16:02:52.792Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chaozhouzhang.github.io/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java多线程 | Android技术堆栈</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Android技术堆栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaozhouzhang.github.io/2021/09/09/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpeg">
      <meta itemprop="name" content="张潮州">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Android技术堆栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-09 22:31:55" itemprop="dateCreated datePublished" datetime="2021-09-09T22:31:55+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-15 00:02:52" itemprop="dateModified" datetime="2021-09-15T00:02:52+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h3><p>1、定义Thread子类，重写线程执行体也就是run方法。<br>2、创建Thread子类的实例，也就是线程对象。<br>3、调用线程对象的start方法来启动该线程，也就是run方法中的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class StackThread extends Thread &#123;</span><br><span class="line">    private int mNum = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();//有无均可，此时Thread中target肯定是空的。</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackThread stackThread = new StackThread();</span><br><span class="line">        stackThread.start();</span><br><span class="line">        StackThread stackThread1 = new StackThread();</span><br><span class="line">        stackThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>使用继承Thread类的方法创建线程类时，多个线程之间无法共享线程类的实例变量。</p>
<h3 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h3><p>1、定义Runnable接口的实现类，重写该接口的run方法。<br>2、创建Runnable实现类的实例，将实例作为Thread的target属性来创建线程对象。<br>3、调用线程对象的start方法来启动线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StackRunnable implements Runnable&#123;</span><br><span class="line">    private int mNum=0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mNum++;</span><br><span class="line">        System.out.println(mNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        Thread thread = new Thread(stackRunnable);//此处的stackRunnable就是Thread中的target</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread thread1 = new Thread(stackRunnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>使用Runnable接口的方式，创建多个使用共同target的线程时，多个线程共享Runnable实现类的变量。</p>
<h3 id="Thread与Runnable的关系"><a href="#Thread与Runnable的关系" class="headerlink" title="Thread与Runnable的关系"></a>Thread与Runnable的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">    	if (target != null) &#123;</span><br><span class="line">        	target.run();</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread类实现了Runnable接口，并且拥有Runnable类型的属性变量target。<br>所以若是以Thread子类的方式实现，则执行的是Thread子类的run方法；<br>若是以实现Runnable接口的方式实现，则执行的是Thread类中run方法，继而执行的是Runnable实现类中的run方法。<br>不存在既有Thread子类实现、又有Runnable接口实现的方式，Thread子类不能传入Runnable实现类实例作为构造参数来创建线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StackThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackRunnable stackRunnable = new StackRunnable();</span><br><span class="line">        StackThread thread = new StackThread(stackRunnable);//无法编译成功</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h3><p>Callable接口提供了一个call方法作为线程执行体。<br>特性：call方法有返回值，且可以抛出异常。<br>因为call方法有返回值，所以Callable接口是一个泛型接口，实现Callable接口的时候需要传入泛型类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future接口，是异步计算结果的容器接口。<br>提供了在等待异步计算完成时检查计算是否完成的状态，并在异步计算完成后获取计算结果而且只能通过 get 方法获取结果，如果异步计算没有完成则阻塞。<br>可以在异步计算完成前通过 cancel 方法取消，如果异步计算被取消则标记一个取消的状态。<br>如果希望异步计算可以被取消而且不提供可用的计算结果，则可以声明 Future&lt;?&gt; 形式类型，并返回 null 作为底层任务的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);//试图取消Future也就是FutureTask里关联的Callable任务。</span><br><span class="line">    boolean isCancelled();//如果在Callable任务正常完成前被取消，返回true。</span><br><span class="line">    boolean isDone();//任务已经结束，在任务完成、任务取消、任务异常的情况下都返回true。</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;//返回Callable任务里call方法的返回值，此方法会导致程序阻塞，必须等到子线程结束后才会得到返回值。</span><br><span class="line">    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;////如果在指定单位时间内没有返回值，将会抛出异常。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunnableFuture接口，继承了Future接口和Runnable接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FutureTask类，实现了RunnableFuture接口。"><a href="#FutureTask类，实现了RunnableFuture接口。" class="headerlink" title="FutureTask类，实现了RunnableFuture接口。"></a>FutureTask类，实现了RunnableFuture接口。</h4><p>Callable构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">    if (callable == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.callable = callable;</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable和返回值构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Executors的callable方法将Runnable和结果值生成Callable对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable适配器实现了Callable接口，并包含Runnable属性，实现的call方法中调用Runnable的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    private final Runnable task;</span><br><span class="line">    private final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final int NEW          = 0;//新建</span><br><span class="line">private static final int COMPLETING   = 1;//计算中</span><br><span class="line">private static final int NORMAL       = 2;//正常</span><br><span class="line">private static final int EXCEPTIONAL  = 3;//异常</span><br><span class="line">private static final int CANCELLED    = 4;//已取消</span><br><span class="line">private static final int INTERRUPTING = 5;//中断中</span><br><span class="line">private static final int INTERRUPTED  = 6;//已中断</span><br></pre></td></tr></table></figure>
<p>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Callable&lt;V&gt; callable;//执行任务</span><br><span class="line">private Object outcome;//执行结果，或者异常</span><br><span class="line">private volatile Thread runner;//执行线程</span><br><span class="line">private volatile WaitNode waiters;//等待的线程栈</span><br></pre></td></tr></table></figure>
<p>FutureTask实现了Runnable接口，所以可以作为Thread的target，所以Thread执行的是FutureTask的run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        runner = null;</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而FutureTask的run方法中执行的是Callable实例的call方法。<br>FutureTask的方法是阻塞方法，直到获取到到结果才返回值，结束阻塞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：<br>FutureTask与Callable：<br>1、创建Callable接口的实现类，并实现call方法作为线程执行体，并返回值，再创建Callable实现类的实例。<br>2、使用FutureTask类来包装Callable对象，FutureTask对象封装了Callable对象中call方法的返回值。<br>3、使用FutureTask对象作为Thread对象的target，创建并启动新线程。<br>4、调用FutureTask对象的get方法，来获取子线程执行结束后的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static Integer callable() &#123;</span><br><span class="line">    Integer result=0;</span><br><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            return 100;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>FutureTask与Runnable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    FutureTask futureTask = new FutureTask&lt;Integer&gt;(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    Thread thread = new Thread(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        Integer result = (Integer) futureTask.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>1、新建状态。<br>新建一个线程，Java虚拟机为其分配内存，并初始化其成员变量的值。<br>2、就绪状态。<br>当线程对象调用了start方法，线程处于就绪状态，Java虚拟机会为该线程创建方法调用栈和程序计数器，表示可以运行，什么时候运行取决于Java虚拟机里线程调度器的调度。<br>只能对处于新建状态的线程调用start方法，否则会抛出IllegalThreadStateException异常。<br>3、运行状态。<br>如果处于就绪状态的线程获得了CPU的时间，开始执行run方法的线程执行体，则该线程处于运行状态，多处理器的机器上将会有多个线程并行parallel执行。<br>4、阻塞状态。<br>除非线程的执行体够短，瞬间被执行结束，否则线程不会一直处于运行状态，线程在运行过程中会被中断，剥夺该线程所占用的资源，目的是使其他线程获得执行的机会。<br>抢占式调度。系统给每个线程一个时间片段执行，用完后执行其他线程，且会考虑线程的优先级。<br>协作式调度。线程主动调用了sleep或yeild方法后才会放弃所占用的资源。</p>
<p>线程将会进入阻塞状态：<br>线程调用sleep方法主动放弃所占用的处理器资源。<br>线程调用了一个阻塞式IO方法，在方法返回之前线程会被阻塞。<br>线程视图获取同步监视器，但该同步监视器正在被其他线程所持有。<br>线程在等待某个通知notify。<br>线程被调用了suspend方法被挂起。但suspend方法容易发生死锁，应该尽量避免使用。</p>
<p>当前正在执行的线程被阻塞后，其他就绪的线程将会获得执行的机会，之后在合适的时候被阻塞的线程将会重新进入就绪状态，等待系统调度器再次调度该线程。</p>
<p>解除阻塞，进入就绪状态：<br>调用sleep方法的线程进过了指定时间。<br>线程调用的阻塞式IO方法已经返回。<br>线程成功地获取了试图获取的同步监视器。<br>线程正在等待某个通知时，其他线程发送了一个通知。<br>处于挂起状态的线程被调用了resume恢复方法。</p>
<p>线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。<br>就绪状态线程获取处理器资源后进入运行状态，运行状态线程失去处理器资源后进入就绪状态，由系统线程调度决定。<br>调用yield方法可以让运行状态线程进入就绪状态。</p>
<p>5、死亡状态。<br>run方法或call方法执行完成，线程正常结束。<br>线程抛出一个未捕获的异常exception或错误error。<br>直接调用线程的stop方法结束线程，容易导致死锁，不建议使用。<br>线程的isAlive方法，判断线程是否存活，线程处于就绪、运行、阻塞状态返回true，线程处于新建、死亡状态返回false。</p>
<h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><p>join线程：<br>在当前线程调用某线程的join方法，当前线程将被阻塞，直到某线程执行完成为止。</p>
<p>后台/守护/精灵/Daemon线程：<br>Java垃圾回收线程就是典型的后台线程。<br>如果所有的前台线程都死亡，那么后台线程会自动死亡。<br>调用线程的setDaemon(true)方法可以将线程设置为后台线程，但必须在start方法之前设置，否则会抛出IllegalThreadStateException异常。<br>线程的isDaemon方法判断方法是否是后台线程。</p>
<p>线程睡眠sleep：<br>调用线程的sleep方法，让正在执行的线程暂停一段时间，并进入阻塞状态，在其睡眠时间内，该线程不会获得执行的机会。</p>
<p>线程的yield方法只是让线程暂停一下，但不会让线程进入阻塞状态，而是让线程进入就绪状态，并让系统的线程调度重新调度，有可能又重新将该线程调度出来执行，具体哪个线程被调度到，需要看线程的优先级。</p>
<p>sleep方法声明了InterruptedException异常，yield方法没有，不建议使用yield方法控制并发线程的执行。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程默认优先级与创建它的父线程优先级相同。<br>线程通过setPriority(int newPriority)、getPriority设置和获取线程的优先级。<br>MAX_PRIORITY 10<br>MIN__PRIORITY 1<br>NORMAL_PRIORITY 5</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步代码块。<br>线程的run方法不具备同步安全性，为了解决这个问题，Java的多线程引入了同步监视器，使用同步监视器的通用方法就是同步代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj)&#123;</span><br><span class="line">	//同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obj就是同步监视器，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。<br>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码执行完成后，该线程会释放对同步监视器的锁定。<br>同步监视器的目的：<br>阻止两个线程对同一个共享资源的并发访问，推荐使用可能被并发访问的共享资源充当同步监视器。</p>
<p>同步方法。<br>synchronized修饰的非静态实例方法，同步监视器是this，也就是调用该方法的对象。</p>
<p>线程安全的类：<br>该类的对象可以被多个线程安全地访问。<br>每个线程调用该对象的任意方法之后都将得到正确的结果。<br>每个线程调用该对象的任意方法之后，该对象的状态依然保持合理状态。</p>
<p>可变类的线程安全是以降低程序的运行效率作为代价的，所以只对会改变竞争资源的方法同步，且提供单线程和多线程两种版本，例如单线程使用StringBuilder保证性能，多线程使用StringBuffer保证多线程安全。</p>
<p>线程释放对同步监视器的锁定：<br>线程的同步方法、同步代码快执行结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到未处理的error和exception结束，释放同步监视器。<br>线程的同步代码块、同步方法中遇到break、return终止，释放同步监视器。<br>线程的同步代码块、同步方法执行的同时，程序执行了同步监视器对象的wait方法，当前线程暂停，释放同步监视器。而调用线程sleep方法和yield方法，其他线程调用该线程的suspend方法都不会释放同步监视器。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>通过显式定义同步锁Lock对象来实现同步，同步锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象。</p>
<p>读写锁：ReadWriteLock。<br>可重入锁：ReentrantLock，显式加锁、释放锁。<br>可重入性：线程可以对已被加锁的ReentrantLock锁对象再次加锁，ReentrantLock对象会维持一个计数器追踪lock方法的嵌套调用，线程每次调用lock加锁后，必须显式地调用unlock来释放锁，所以一段被锁保护的代码可以调用另一个被锁保护的代码。<br>可重入读写锁：ReentrantReadWriteLock。<br>StampedLock：是为了优化可重入读写锁性能的一个锁实现工具。<br>Lock显式地使用Lock对象作为同步锁，同步方法/块是系统隐式地使用当前对象作为同步监视器。<br>使用finally块，确保在必要时释放锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>线程互相等待对方释放同步监视器，就会发生死锁，所有线程处于阻塞状态，无法继续。<br>Thread类的suspend方法容易产生死锁，不建议使用。</p>
<h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>Object类的wait、notify、notifyAll方法，由同步监视器对象来调用进行线程通信。</p>
<p>为什么wait，notify，notifyAll这些跟线程有关的方法是封装在Object中而不线程的Thread类呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为可以把任意的对象作为锁资源进行竞争，所以任意对象都可以调用wait()和notify()，而Object是所有类的父类，所以wait和notify属于Object。</span><br></pre></td></tr></table></figure>
<p>notify：唤醒在此对象监视器上等待的单个线程。<br>notifyAll：唤醒在此对象监视器上等待的所有线程。<br>wait：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法。<br>wait(long timeout)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者超过指定的时间量。<br>wait(long timeout, int nanos)：导致当前的线程等待，直到其他线程调用此对象的notify方法或notifyAll方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>

    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/08/28/OpenGL-ES-3-0-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="next" title="OpenGL ES 3.0 编程指南读书笔记">
                  <i class="fa fa-chevron-left"></i> OpenGL ES 3.0 编程指南读书笔记
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/09/19/%E8%A7%86%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/" rel="prev" title="视音频技术">
                  视音频技术 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类创建线程类"><span class="nav-number">2.0.1.</span> <span class="nav-text">继承Thread类创建线程类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Runnable接口创建线程类"><span class="nav-number">2.0.2.</span> <span class="nav-text">实现Runnable接口创建线程类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread与Runnable的关系"><span class="nav-number">2.0.3.</span> <span class="nav-text">Thread与Runnable的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Callable和Future创建线程"><span class="nav-number">2.0.4.</span> <span class="nav-text">使用Callable和Future创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask类，实现了RunnableFuture接口。"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">FutureTask类，实现了RunnableFuture接口。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">2.1.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制线程"><span class="nav-number">2.2.</span> <span class="nav-text">控制线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-number">2.3.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">2.4.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步锁"><span class="nav-number">2.5.</span> <span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">2.6.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程通信"><span class="nav-number">3.</span> <span class="nav-text">线程通信</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="张潮州"
    src="/images/header.jpeg">
  <p class="site-author-name" itemprop="name">张潮州</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张潮州</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  

</body>
</html>
